{"meta":{"title":"Hexo","subtitle":"","description":"","author":"jianguo","url":"https://fjianguo.github.io/jianguo.github.io","root":"/jianguo.github.io/"},"pages":[],"posts":[{"title":"Java 爬取微博热搜榜数据，存入数据库","slug":"study19","date":"2020-11-23T11:05:50.000Z","updated":"2020-11-23T11:40:58.196Z","comments":true,"path":"2020/11/23/study19/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/11/23/study19/","excerpt":"","text":"Java 爬取微博热搜榜数据，存入数据库 获取访问微博热搜榜的地址 https://s.weibo.com/top/summary/summary?cate=realtimehot 使用 Document 解析页面1Document document &#x3D; Jsoup.connect(url).get(); 使用 Elements 获取指定元素内容，并存入数组12Elements elements &#x3D; document.select(&quot;span&quot;);&#x2F;&#x2F;span为需求元素对应标签String[] str &#x3D; elements.eachText().toArray(new String[0]); 具体实现12345678910111213141516171819202122232425262728293031323334353637383940public class Test &#123; public static void main(String[] args)&#123; String myUrl &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;weibo?usaSSl&#x3D;false&amp;serverTimezone&#x3D;UTC&quot;; String name &#x3D; &quot;root&quot;; String pwd &#x3D; &quot;156176pwd&quot;; String sql &#x3D; &quot;INSERT INTO search(s_rank,s_title,s_view) VALUES(?,?,?)&quot;; String url &#x3D; &quot;https:&#x2F;&#x2F;s.weibo.com&#x2F;top&#x2F;summary&#x2F;summary?cate&#x3D;realtimehot&quot;; try &#123; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); Connection connection &#x3D; DriverManager.getConnection(myUrl, name, pwd); Document document &#x3D; Jsoup.connect(url).get(); Elements r &#x3D; document.select(&quot;td[class&#x3D;&#39;td-01 ranktop&#39;]&quot;); String[] rank &#x3D; r.eachText().toArray(new String[0]); Elements t &#x3D; document.select(&quot;td[class&#x3D;&#39;td-02&#39;] a&quot;); String[] title &#x3D; t.eachText().toArray(new String[0]); Elements v &#x3D; document.select(&quot;span&quot;); String[] view &#x3D; v.eachText().toArray(new String[0]); PreparedStatement statement &#x3D; connection.prepareStatement(sql); for (int i &#x3D; 0; i &lt; rank.length; i++) &#123; statement.setString(1, rank[i]); statement.setString(2, title[i + 1]); statement.setString(3, view[i]); statement.setString(4, time); statement.executeUpdate(); &#125; connection.close(); &#125; catch (IOException | ClassNotFoundException | SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"Go Web基础","slug":"study18","date":"2020-11-23T09:19:42.000Z","updated":"2020-11-23T11:07:36.321Z","comments":true,"path":"2020/11/23/study18/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/11/23/study18/","excerpt":"Web基础 使用http包搭建Web服务器123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;net&#x2F;http&quot; &quot;strings&quot; &quot;log&quot;)func sayhelloName(w http.ResponseWriter, r *http.Request) &#123; r.ParseForm() &#x2F;&#x2F;解析参数，默认是不会解析的 for k, v :&#x3D; range r.Form &#123; fmt.Println(&quot;key:&quot;, k) fmt.Println(&quot;val:&quot;, strings.Join(v, &quot;&quot;)) fmt.Fprintf(w, k+&quot;:&quot;) fmt.Fprintf(w, strings.Join(v, &quot;&quot;)+&quot;,&quot;) &#125; fmt.Fprintf(w, &quot;Hello Go!&quot;) &#x2F;&#x2F;这个写入到w的是输出到客户端的&#125;func main() &#123; http.HandleFunc(&quot;&#x2F;&quot;, sayhelloName) &#x2F;&#x2F;设置访问的路由 err :&#x3D; http.ListenAndServe(&quot;:9090&quot;, nil) &#x2F;&#x2F;设置监听的端口 if err !&#x3D; nil &#123; log.Fatal(&quot;ListenAndServe: &quot;, err) &#125;&#125; 执行后访问 http://localhost:9090 即可看到浏览器显示Hello Go！字样,http://localhost:9090/?test=111&amp;test=222 浏览器可显示传入参数","text":"Web基础 使用http包搭建Web服务器123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;net&#x2F;http&quot; &quot;strings&quot; &quot;log&quot;)func sayhelloName(w http.ResponseWriter, r *http.Request) &#123; r.ParseForm() &#x2F;&#x2F;解析参数，默认是不会解析的 for k, v :&#x3D; range r.Form &#123; fmt.Println(&quot;key:&quot;, k) fmt.Println(&quot;val:&quot;, strings.Join(v, &quot;&quot;)) fmt.Fprintf(w, k+&quot;:&quot;) fmt.Fprintf(w, strings.Join(v, &quot;&quot;)+&quot;,&quot;) &#125; fmt.Fprintf(w, &quot;Hello Go!&quot;) &#x2F;&#x2F;这个写入到w的是输出到客户端的&#125;func main() &#123; http.HandleFunc(&quot;&#x2F;&quot;, sayhelloName) &#x2F;&#x2F;设置访问的路由 err :&#x3D; http.ListenAndServe(&quot;:9090&quot;, nil) &#x2F;&#x2F;设置监听的端口 if err !&#x3D; nil &#123; log.Fatal(&quot;ListenAndServe: &quot;, err) &#125;&#125; 执行后访问 http://localhost:9090 即可看到浏览器显示Hello Go！字样,http://localhost:9090/?test=111&amp;test=222 浏览器可显示传入参数 使用http包获取API接口数据1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( &quot;database&#x2F;sql&quot; &quot;encoding&#x2F;json&quot; &quot;fmt&quot; &quot;io&#x2F;ioutil&quot; &quot;net&#x2F;http&quot; _ &quot;github.com&#x2F;go-sql-driver&#x2F;mysql&quot;)type weibo struct &#123; Hotword string Hotwordnum string&#125;type weiboslice struct &#123; Code int Msg string Newslist []weibo&#125;func main() &#123; var s weiboslice resp, err :&#x3D; http.Get(&quot;http:&#x2F;&#x2F;api.tianapi.com&#x2F;txapi&#x2F;weibohot&#x2F;index?key&#x3D;ce980c8efa44d2e151e24fb175c3299b&quot;) if err !&#x3D; nil &#123; fmt.Println(&quot;http get error.&quot;) &#125; defer resp.Body.Close() body, err :&#x3D; ioutil.ReadAll(resp.Body) if err !&#x3D; nil &#123; fmt.Println(&quot;http read error&quot;) return &#125; src :&#x3D; string(body) json.Unmarshal([]byte(src), &amp;s) fmt.Println(s)&#125;","categories":[],"tags":[]},{"title":"Go使用Mysql数据库","slug":"study17","date":"2020-11-23T07:54:55.000Z","updated":"2020-11-23T11:07:24.513Z","comments":true,"path":"2020/11/23/study17/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/11/23/study17/","excerpt":"Mysql数据库 Mysql驱动https://github.com/go-sql-driver/mysql Mysql实例 创建数据库，数据表12345678CREATE database test；CREATE TABLE &#96;userinfo&#96; ( &#96;id&#96; INT(10) NOT NULL AUTO_INCREMENT, &#96;username&#96; VARCHAR(64) NULL DEFAULT NULL, &#96;password&#96; VARCHAR(64) NULL DEFAULT NULL, &#96;age&#96; VARCHAR(10) NULL DEFAULT NULL, PRIMARY KEY (&#96;id&#96;))","text":"Mysql数据库 Mysql驱动https://github.com/go-sql-driver/mysql Mysql实例 创建数据库，数据表12345678CREATE database test；CREATE TABLE &#96;userinfo&#96; ( &#96;id&#96; INT(10) NOT NULL AUTO_INCREMENT, &#96;username&#96; VARCHAR(64) NULL DEFAULT NULL, &#96;password&#96; VARCHAR(64) NULL DEFAULT NULL, &#96;age&#96; VARCHAR(10) NULL DEFAULT NULL, PRIMARY KEY (&#96;id&#96;)) 对数据库进行增删改查1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package mainimport ( _ &quot;github.com&#x2F;go-sql-driver&#x2F;mysql&quot; &quot;database&#x2F;sql&quot; &quot;fmt&quot;)func main() &#123; db, err :&#x3D; sql.Open(&quot;mysql&quot;, &quot;用户名:密码@&#x2F;test?charset&#x3D;utf8&quot;) checkErr(err) &#x2F;&#x2F;插入数据 stmt, err :&#x3D; db.Prepare(&quot;INSERT userinfo SET username&#x3D;?,password&#x3D;?,age&#x3D;?&quot;) checkErr(err) res, err :&#x3D; stmt.Exec(&quot;username&quot;, &quot;password&quot;, &quot;age&quot;) checkErr(err) id :&#x3D; 1 &#x2F;&#x2F;更新数据 stmt, err &#x3D; db.Prepare(&quot;update userinfo set username&#x3D;? where id&#x3D;?&quot;) checkErr(err) res, err &#x3D; stmt.Exec(&quot;修改后username&quot;, id) checkErr(err) affect, err :&#x3D; res.RowsAffected() checkErr(err) fmt.Println(affect) &#x2F;&#x2F;查询数据 rows, err :&#x3D; db.Query(&quot;SELECT * FROM userinfo&quot;) checkErr(err) for rows.Next() &#123; var id int var username string var password string var age string err &#x3D; rows.Scan(&amp;uid, &amp;username, &amp;password, &amp;age) checkErr(err) fmt.Println(id) fmt.Println(username) fmt.Println(password) fmt.Println(age) &#125; &#x2F;&#x2F;删除数据 stmt, err &#x3D; db.Prepare(&quot;delete from userinfo where id&#x3D;?&quot;) checkErr(err) res, err &#x3D; stmt.Exec(2)&#x2F;&#x2F;id值 checkErr(err) affect, err &#x3D; res.RowsAffected() checkErr(err) fmt.Println(affect) db.Close()&#125;func checkErr(err error) &#123; if err !&#x3D; nil &#123; panic(err) &#125;&#125;","categories":[],"tags":[]},{"title":"Android图表控件MPAndroidChart之LineChart","slug":"study16","date":"2020-11-23T06:29:03.000Z","updated":"2020-11-23T11:07:05.651Z","comments":true,"path":"2020/11/23/study16/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/11/23/study16/","excerpt":"LineChart 简单代码123456789101112&lt;RelativeLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:orientation&#x3D;&quot;vertical&quot;&gt; &lt;com.github.mikephil.charting.charts.LineChart android:id&#x3D;&quot;@+id&#x2F;lineChart&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;300dp&quot; android:layout_centerInParent&#x3D;&quot;true&quot;&#x2F;&gt;&lt;&#x2F;RelativeLayout&gt; 1234567891011121314151617@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); LineChart mLineChart &#x3D; (LineChart) findViewById(R.id.lineChart); &#x2F;&#x2F;显示边界 mLineChart.setDrawBorders(true); &#x2F;&#x2F;设置数据 List&lt;Entry&gt; yList &#x3D; new ArrayList&lt;&gt;(); for (int i &#x3D; 0; i &lt; 10; i++) &#123; yList.add(new Entry(i, (float) (Math.random()) * 80)); &#125; &#x2F;&#x2F;一个LineDataSet就是一条线 LineDataSet lineDataSet &#x3D; new LineDataSet(yList, &quot;曲线描述&quot;); LineData data &#x3D; new LineData(lineDataSet); mLineChart.setData(data);&#125;","text":"LineChart 简单代码123456789101112&lt;RelativeLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:orientation&#x3D;&quot;vertical&quot;&gt; &lt;com.github.mikephil.charting.charts.LineChart android:id&#x3D;&quot;@+id&#x2F;lineChart&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;300dp&quot; android:layout_centerInParent&#x3D;&quot;true&quot;&#x2F;&gt;&lt;&#x2F;RelativeLayout&gt; 1234567891011121314151617@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); LineChart mLineChart &#x3D; (LineChart) findViewById(R.id.lineChart); &#x2F;&#x2F;显示边界 mLineChart.setDrawBorders(true); &#x2F;&#x2F;设置数据 List&lt;Entry&gt; yList &#x3D; new ArrayList&lt;&gt;(); for (int i &#x3D; 0; i &lt; 10; i++) &#123; yList.add(new Entry(i, (float) (Math.random()) * 80)); &#125; &#x2F;&#x2F;一个LineDataSet就是一条线 LineDataSet lineDataSet &#x3D; new LineDataSet(yList, &quot;曲线描述&quot;); LineData data &#x3D; new LineData(lineDataSet); mLineChart.setData(data);&#125; XAxis(X轴)介绍12345XAxis xAxis &#x3D; mLineChart.getXAxis();&#x2F;&#x2F;得到X轴xAxis.setPosition(XAxis.XAxisPosition.BOTTOM);&#x2F;&#x2F;X轴显示位置，值：BOTTOM,BOTH_SIDED,BOTTOM_INSIDE,TOP,TOP_INSIDExAxis.setLabelCount(10, true);&#x2F;&#x2F;X轴刻度数量，true表示平均分配X轴，false表示根据曲线X值分配点xAxis.setAxisMinimum();xAxis.setAxisMaximum();&#x2F;&#x2F;X轴最大最小值 YAxis(Y轴)介绍12345678YAxis leftYAxis &#x3D; mLineChart.getAxisLeft();YAxis rightYAxis &#x3D; mLineChart.getAxisRight();&#x2F;&#x2F;得到Y轴，分左右leftYAxis.setAxisMinimum();leftYAxis.setAxisMaximum();rightYAxis.setAxisMinimum();rightYAxis.setAxisMaximum();&#x2F;&#x2F;设置左右Y轴最大最小值rightYAxis.setEnabled(false);&#x2F;&#x2F;设置是否显示右侧Y轴rightYAxis.setLabelCount(10, false);&#x2F;&#x2F;同X轴 Legend(图例)介绍123456legend.setTextColor(Color.CYAN); &#x2F;&#x2F;设置Legend 文本颜色legend.setVerticalAlignment(Legend.LegendVerticalAlignment.BOTTOM);legend.setHorizontalAlignment(Legend.LegendHorizontalAlignment.CENTER);legend.setOrientation(Legend.LegendOrientation.HORIZONTAL);legend.setWordWrapEnabled(true);&#x2F;&#x2F;设置标签是否可换行legend.setEnabled(false);&#x2F;&#x2F;是否隐藏图例 曲线设置12345678&#x2F;&#x2F;一个LineDataSet就是一条线LineDataSet lineDataSet &#x3D; new LineDataSet(yList, &quot;曲线描述&quot;);&#x2F;&#x2F;设置曲线值的圆点是实心还是空心lineDataSet.setDrawCircleHole(false);&#x2F;&#x2F;设置显示值的字体大小lineDataSet.setValueTextSize(9f);&#x2F;&#x2F;设置为圆滑曲线（默认折线）lineDataSet.setMode(LineDataSet.Mode.CUBIC_BEZIER);","categories":[],"tags":[]},{"title":"Spring Boot + Mybatis + Mysql实例","slug":"study15","date":"2020-11-20T11:05:08.000Z","updated":"2020-11-20T12:24:54.264Z","comments":true,"path":"2020/11/20/study15/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/11/20/study15/","excerpt":"Spring Boot + Mybatis + Mysql实例 创建Spring Boot项目 application.properties配置数据库连接信息12345678spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;数据库名?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;serverTimezone&#x3D;UTCspring.datasource.username&#x3D;用户名spring.datasource.password&#x3D;密码spring.datasource.driver-class-name&#x3D;com.mysql.cj.jdbc.Driver## Mybatis 配置mybatis.typeAliasesPackage&#x3D;com.jianguo.domainmybatis.mapperLocations&#x3D;classpath:mapper&#x2F;*.xml","text":"Spring Boot + Mybatis + Mysql实例 创建Spring Boot项目 application.properties配置数据库连接信息12345678spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;数据库名?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;serverTimezone&#x3D;UTCspring.datasource.username&#x3D;用户名spring.datasource.password&#x3D;密码spring.datasource.driver-class-name&#x3D;com.mysql.cj.jdbc.Driver## Mybatis 配置mybatis.typeAliasesPackage&#x3D;com.jianguo.domainmybatis.mapperLocations&#x3D;classpath:mapper&#x2F;*.xml 代码编写 创建实体类对应Mysql表的列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class User &#123; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username &#x3D; username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password &#x3D; password; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age &#x3D; age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex &#x3D; sex; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id &#x3D; id; &#125; public Long id public String username; public String password; public int age; public String sex;&#125; 创建方法接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051UserDao(位于dao包内)public interface UserDao &#123;&#x2F;** * 获取微博信息列表 * * @return *&#x2F;List&lt;User&gt; findAll();Long saveUser(User user);Long updateUser(User user);Long deleteUser(Long id);&#125;UserService(位于service包内)public interface UserService &#123;&#x2F;** * 获取信息列表 * * @return *&#x2F;List&lt;User&gt; findAll();&#x2F;** * 新增信息 * * @param user * @return *&#x2F;Long saveUser(User user);&#x2F;** * 修改信息 * * @param user * @return *&#x2F;Long updateUser(User user);&#x2F;** *根据 ID,删除信息 * * @param id * @return *&#x2F;Long deleteUser(Long id); 接口继承实现123456789101112131415161718192021222324UserServiceImpl(位于service&#x2F;impl包内)@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; public List&lt;User&gt; findAll()&#123;return userDao.findAll();&#125; @Override public Long saveUser(User user) &#123; return userDao.saveUser(user); &#125; @Override public Long updateUser(User user) &#123; return userDao.updateUser(user); &#125; @Override public Long deleteUser(Long id) &#123; return userDao.deleteUser(id); &#125;&#125; controller层123456789101112131415161718192021222324@RestControllerpublic class UserController &#123; @Autowired private UserService userService; @RequestMapping(value&#x3D;&quot;&#x2F;user&quot;, method &#x3D; RequestMethod.POST) public List&lt;User&gt; findAll()&#123;return userService.findAll();&#125; @RequestMapping(value &#x3D; &quot;&#x2F;user&#x2F;insert&quot;, method &#x3D; RequestMethod.POST) public void createUser(@RequestBody(required&#x3D;false) User user) &#123; userService.saveUser(user); &#125; @RequestMapping(value &#x3D; &quot;&#x2F;user&#x2F;update&quot;, method &#x3D; RequestMethod.POST) public void modifyUser(@RequestBody(required&#x3D;false) User user) &#123; userService.updateUser(user); &#125; @RequestMapping(value &#x3D; &quot;&#x2F;user&#x2F;delete&quot;, method &#x3D; RequestMethod.POST) public void modifyUser(@RequestParam(value &#x3D; &quot;id&quot;,required &#x3D; false) Long id) &#123; userService.deleteUser(id); &#125;&#125; Mysql操作，resources/mapper下创建UserMapper.xml文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace&#x3D;&quot;com.jianguo.dao.UserDao&quot;&gt; &lt;resultMap id&#x3D;&quot;BaseResultMap&quot; type&#x3D;&quot;com.jianguo.domain.User&quot;&gt; &lt;result column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot;&#x2F;&gt; &#x2F;&#x2F;column对应mysql表字段名，property对应实体类变量名 &lt;result column&#x3D;&quot;username&quot; property&#x3D;&quot;username&quot;&#x2F;&gt; &lt;result column&#x3D;&quot;password&quot; property&#x3D;&quot;password&quot;&#x2F;&gt; &lt;result column&#x3D;&quot;age&quot; property&#x3D;&quot;age&quot;&#x2F;&gt; &lt;result column&#x3D;&quot;sex&quot; property&#x3D;&quot;sex&quot;&#x2F;&gt; &lt;&#x2F;resultMap&gt; &lt;sql id&#x3D;&quot;Base_Column_List&quot;&gt; id, username, password, age, sex &lt;&#x2F;sql&gt; &lt;select id&#x3D;&quot;findAll&quot; resultMap&#x3D;&quot;BaseResultMap&quot;&gt; select &lt;include refid&#x3D;&quot;Base_Column_List&quot;&#x2F;&gt; from 表名 &lt;&#x2F;select&gt; &lt;insert id&#x3D;&quot;saveUser&quot; parameterType&#x3D;&quot;User&quot; useGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;id&quot;&gt; insert into 表名(username,password,age,sex) values (#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;) &lt;&#x2F;insert&gt; &lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;User&quot;&gt; update 表名 set username &#x3D; #&#123;username&#125;, password &#x3D; #&#123;password&#125;, age &#x3D; #&#123;age&#125; sex &#x3D; #&#123;sex&#125; where id &#x3D; #&#123;id&#125; &lt;&#x2F;update&gt; &lt;delete id&#x3D;&quot;deleteUser&quot; parameterType&#x3D;&quot;java.lang.Long&quot;&gt; delete from 表名 where id &#x3D; #&#123;id&#125; &lt;&#x2F;delete&gt;&lt;&#x2F;mapper&gt; Application代码1234567@SpringBootApplication@MapperScan(&quot;com.jianguo.dao&quot;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125;","categories":[],"tags":[]},{"title":"Java之Spring Boot","slug":"study14","date":"2020-11-20T10:12:08.000Z","updated":"2020-11-20T10:36:54.746Z","comments":true,"path":"2020/11/20/study14/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/11/20/study14/","excerpt":"","text":"Spring Boot的优点 简单易用，只需要懂java、c#、php、js都能快速入门 功能强大，几乎不用自己从头开发功能 部署方便 Spring Boot使用 创建一个maven项目，main包下新建resources包，resources包下新建application.properties文件(数据源等内容在其中配置) 配置pom.xml123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;!-- Spring Boot Web 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- Spring Boot Test 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;!-- Junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.12&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- Spring Boot Mybatis 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.3&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; 代码编写 一般我们将代码分应用层（Controller）、服务层（Service）、数据层（Dao） 项目分层 Hello World编写1234567891011121314151617Application 代码@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125;Controller代码（controller下新建java文件）@RestController@RequestMapping(&quot;&#x2F;hello&quot;)public class HelloWorldController &#123; @RequestMapping(&quot;&#x2F;say&quot;) public String say()&#123; return &quot;Hello World&quot;; &#125;&#125;","categories":[],"tags":[]},{"title":"Android使用Bottom Navigation Activity来实现底部导航栏","slug":"study13","date":"2020-11-20T09:09:25.000Z","updated":"2020-11-20T12:24:35.258Z","comments":true,"path":"2020/11/20/study13/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/11/20/study13/","excerpt":"实现 新建项目选择Bottom Navigation Activity，Android会自动创建好带有底部导航的项目。 其中在activity_main.xml中定义了底部导航1234567891011&lt;com.google.android.material.bottomnavigation.BottomNavigationView android:id&#x3D;&quot;@+id&#x2F;nav_view&quot; android:layout_width&#x3D;&quot;0dp&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_marginStart&#x3D;&quot;0dp&quot; android:layout_marginEnd&#x3D;&quot;0dp&quot; android:background&#x3D;&quot;?android:attr&#x2F;windowBackground&quot; app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot; app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot; app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot; app:menu&#x3D;&quot;@menu&#x2F;bottom_nav_menu&quot; &#x2F;&gt; menu文件下bottom_nav_menu.xml文件指定了导航的描述，可根据自身需求修改添加。12345678910111213141516171819&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;menu xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt; &lt;item android:id&#x3D;&quot;@+id&#x2F;navigation_home&quot; android:icon&#x3D;&quot;@drawable&#x2F;ic_home_black_24dp&quot; android:title&#x3D;&quot;@string&#x2F;title_home&quot; &#x2F;&gt; &lt;item android:id&#x3D;&quot;@+id&#x2F;navigation_dashboard&quot; android:icon&#x3D;&quot;@drawable&#x2F;ic_dashboard_black_24dp&quot; android:title&#x3D;&quot;@string&#x2F;title_dashboard&quot; &#x2F;&gt; &lt;item android:id&#x3D;&quot;@+id&#x2F;navigation_notifications&quot; android:icon&#x3D;&quot;@drawable&#x2F;ic_notifications_black_24dp&quot; android:title&#x3D;&quot;@string&#x2F;title_notifications&quot; &#x2F;&gt;&lt;&#x2F;menu&gt;","text":"实现 新建项目选择Bottom Navigation Activity，Android会自动创建好带有底部导航的项目。 其中在activity_main.xml中定义了底部导航1234567891011&lt;com.google.android.material.bottomnavigation.BottomNavigationView android:id&#x3D;&quot;@+id&#x2F;nav_view&quot; android:layout_width&#x3D;&quot;0dp&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_marginStart&#x3D;&quot;0dp&quot; android:layout_marginEnd&#x3D;&quot;0dp&quot; android:background&#x3D;&quot;?android:attr&#x2F;windowBackground&quot; app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot; app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot; app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot; app:menu&#x3D;&quot;@menu&#x2F;bottom_nav_menu&quot; &#x2F;&gt; menu文件下bottom_nav_menu.xml文件指定了导航的描述，可根据自身需求修改添加。12345678910111213141516171819&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;menu xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt; &lt;item android:id&#x3D;&quot;@+id&#x2F;navigation_home&quot; android:icon&#x3D;&quot;@drawable&#x2F;ic_home_black_24dp&quot; android:title&#x3D;&quot;@string&#x2F;title_home&quot; &#x2F;&gt; &lt;item android:id&#x3D;&quot;@+id&#x2F;navigation_dashboard&quot; android:icon&#x3D;&quot;@drawable&#x2F;ic_dashboard_black_24dp&quot; android:title&#x3D;&quot;@string&#x2F;title_dashboard&quot; &#x2F;&gt; &lt;item android:id&#x3D;&quot;@+id&#x2F;navigation_notifications&quot; android:icon&#x3D;&quot;@drawable&#x2F;ic_notifications_black_24dp&quot; android:title&#x3D;&quot;@string&#x2F;title_notifications&quot; &#x2F;&gt;&lt;&#x2F;menu&gt; 底部导航对应的页面，Android会自动创建，只需在对应的页面添加布局即可12345678910111213141516&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot; xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:orientation&#x3D;&quot;vertical&quot; tools:context&#x3D;&quot;.ui.dashboard.DashboardFragment&quot;&gt; &lt;TextView android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;Hello World!&quot; android:textSize&#x3D;&quot;18sp&quot;&#x2F;&gt;&lt;&#x2F;LinearLayout&gt; 添加新的导航，创建对应数量的java文件继承Fragment，bottom_nav_menu.xml添加对应的item，navigation包中mobile_navigation.xml文件添加对应数量的fragment，MainActivity中对应修改。1234567891011public class NewActivity extends Fragment &#123; &#x2F;&#x2F;继承fragment &#x2F;&#x2F;创建视图 @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; &#x2F;&#x2F; Inflate the layout for this fragment return inflater.inflate( R.layout.activity_new, container, false ); &#x2F;&#x2F;要加载的layout文件 &#125; &#125; 1234&lt;item android:id&#x3D;&quot;@+id&#x2F;navigation_new&quot; android:icon&#x3D;&quot;这里是导航图标&quot; android:title&#x3D;&quot;name&quot; &#x2F;&gt; 12345&lt;fragment android:id&#x3D;&quot;@+id&#x2F;navigation_new&quot; android:name&#x3D;&quot;这里是java代码地址&quot; android:label&#x3D;&quot;name&quot; tools:layout&#x3D;&quot;@layout&#x2F;activity_new&quot; &#x2F;&gt; 1234567891011121314@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); BottomNavigationView navView &#x3D; findViewById(R.id.nav_view); &#x2F;&#x2F; Passing each menu ID as a set of Ids because each &#x2F;&#x2F; menu should be considered as top level destinations. AppBarConfiguration appBarConfiguration &#x3D; new AppBarConfiguration.Builder( R.id.navigation_home, R.id.navigation_dashboard, R.id.navigation_notifications,R.id.navigation_new)&#x2F;&#x2F;这里对应导航ID .build(); NavController navController &#x3D; Navigation.findNavController(this, R.id.nav_host_fragment); NavigationUI.setupActionBarWithNavController(this, navController, appBarConfiguration); NavigationUI.setupWithNavController(navView, navController); &#125;","categories":[],"tags":[]},{"title":"Android之侧滑菜单","slug":"study12","date":"2020-11-20T08:18:14.000Z","updated":"2020-11-20T12:24:18.004Z","comments":true,"path":"2020/11/20/study12/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/11/20/study12/","excerpt":"实现 引入依赖1implementation &#39;com.google.android.material:material:1.2.1&#39; 页面布局12345678910111213141516171819202122232425262728293031&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;androidx.drawerlayout.widget.DrawerLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot; android:id&#x3D;&quot;@+id&#x2F;drawer_layout&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot;&gt; &lt;LinearLayout android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:orientation&#x3D;&quot;vertical&quot;&gt; &lt;androidx.appcompat.widget.Toolbar android:id&#x3D;&quot;@+id&#x2F;toolbar&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;?attr&#x2F;actionBarSize&quot; android:background&#x3D;&quot;?attr&#x2F;colorPrimary&quot; android:theme&#x3D;&quot;@style&#x2F;ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme&#x3D;&quot;@style&#x2F;ThemeOverlay.AppCompat.Light&quot; &#x2F;&gt; &lt;&#x2F;LinearLayout&gt; &lt;com.google.android.material.navigation.NavigationView android:id&#x3D;&quot;@+id&#x2F;nav_view&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:layout_gravity&#x3D;&quot;left&quot; app:headerLayout&#x3D;&quot;@layout&#x2F;nav_header&quot; app:menu&#x3D;&quot;@menu&#x2F;nav_menu&quot; &#x2F;&gt;&lt;&#x2F;androidx.drawerlayout.widget.DrawerLayout&gt;","text":"实现 引入依赖1implementation &#39;com.google.android.material:material:1.2.1&#39; 页面布局12345678910111213141516171819202122232425262728293031&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;androidx.drawerlayout.widget.DrawerLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot; android:id&#x3D;&quot;@+id&#x2F;drawer_layout&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot;&gt; &lt;LinearLayout android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:orientation&#x3D;&quot;vertical&quot;&gt; &lt;androidx.appcompat.widget.Toolbar android:id&#x3D;&quot;@+id&#x2F;toolbar&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;?attr&#x2F;actionBarSize&quot; android:background&#x3D;&quot;?attr&#x2F;colorPrimary&quot; android:theme&#x3D;&quot;@style&#x2F;ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme&#x3D;&quot;@style&#x2F;ThemeOverlay.AppCompat.Light&quot; &#x2F;&gt; &lt;&#x2F;LinearLayout&gt; &lt;com.google.android.material.navigation.NavigationView android:id&#x3D;&quot;@+id&#x2F;nav_view&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:layout_gravity&#x3D;&quot;left&quot; app:headerLayout&#x3D;&quot;@layout&#x2F;nav_header&quot; app:menu&#x3D;&quot;@menu&#x2F;nav_menu&quot; &#x2F;&gt;&lt;&#x2F;androidx.drawerlayout.widget.DrawerLayout&gt; 侧滑菜单头部文件NavigationView中app:headerLayout属性引用12345678910111213141516171819202122232425262728293031323334&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;180dp&quot; android:padding&#x3D;&quot;10dp&quot; android:layout_below&#x3D;&quot;?attr&#x2F;colorPrimary&quot; android:background&#x3D;&quot;@color&#x2F;image&quot;&gt; &lt;de.hdodenhof.circleimageview.CircleImageView android:id&#x3D;&quot;@+id&#x2F;icon_image&quot; android:layout_width&#x3D;&quot;70dp&quot; android:layout_height&#x3D;&quot;70dp&quot; android:src&#x3D;&quot;@drawable&#x2F;ic_menu&quot; android:layout_centerInParent&#x3D;&quot;true&quot;&#x2F;&gt; &lt;TextView android:id&#x3D;&quot;@+id&#x2F;mail&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_alignParentBottom&#x3D;&quot;true&quot; android:textSize&#x3D;&quot;14sp&quot; android:text&#x3D;&quot;https:&#x2F;&#x2F;fjianguo.github.io&#x2F;jianguo.github.io&#x2F;&quot; android:textColor&#x3D;&quot;#00f&quot;&#x2F;&gt; &lt;TextView android:id&#x3D;&quot;@+id&#x2F;username&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_above&#x3D;&quot;@+id&#x2F;mail&quot; android:textSize&#x3D;&quot;14sp&quot; android:text&#x3D;&quot;博客&quot; android:textColor&#x3D;&quot;#00f&quot;&#x2F;&gt;&lt;&#x2F;RelativeLayout&gt; 侧滑菜单选项在res包下menu内创建NavigationView中app:headerLayout属性引用，根据自己需求添加“single”属性声明只能选中一个12345678910111213141516171819&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;menu xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt; &lt;group android:checkableBehavior&#x3D;&quot;single&quot;&gt; &lt;item android:id&#x3D;&quot;@+id&#x2F;line&quot; android:title&#x3D;&quot;曲线图&quot;&#x2F;&gt; &lt;item android:id&#x3D;&quot;@+id&#x2F;scatter&quot; android:title&#x3D;&quot;散点图&quot;&#x2F;&gt; &lt;item android:id&#x3D;&quot;@+id&#x2F;pie&quot; android:title&#x3D;&quot;饼图&quot;&#x2F;&gt; &lt;item android:id&#x3D;&quot;@+id&#x2F;bar&quot; android:title&#x3D;&quot;柱型图&quot;&#x2F;&gt; &lt;&#x2F;group&gt;&lt;&#x2F;menu&gt; 代码中引用布局,setNavigationItemSelectedListener方法设置点击时的响应1234567891011121314151617181920212223242526272829303132333435363738394041@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_list_view); Toolbar toolbar &#x3D; (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); drawerLayout &#x3D; (DrawerLayout) findViewById(R.id.drawer_layout); NavigationView navigationView &#x3D; (NavigationView) findViewById(R.id.nav_view); ActionBar actionBar &#x3D; getSupportActionBar(); if (actionBar !&#x3D; null) &#123; actionBar.setDisplayHomeAsUpEnabled(true); actionBar.setHomeAsUpIndicator(R.drawable.ic_menu);&#x2F;&#x2F;菜单按钮图标 &#125; navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.line: Intent intentDiagram &#x3D; new Intent(ListViewActivity.this, TenLineChartActivity.class); startActivity(intentDiagram); break; case R.id.pie: Intent intentPieChart &#x3D; new Intent(ListViewActivity.this, PieChartActivity.class); startActivity(intentPieChart); break; case R.id.bar: Intent intentBarChart &#x3D; new Intent(ListViewActivity.this, BarChartActivity.class); startActivity(intentBarChart); break; case R.id.scatter: Intent intentScatterChart &#x3D; new Intent(ListViewActivity.this, ScatterChartActivity.class); startActivity(intentScatterChart); break; default: drawerLayout.closeDrawers(); break; &#125; return true; &#125; &#125;);&#125;","categories":[],"tags":[]},{"title":"springboot之@RequestBody和@RequestParam","slug":"study11","date":"2020-11-16T11:15:41.000Z","updated":"2020-11-16T11:40:33.712Z","comments":true,"path":"2020/11/16/study11/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/11/16/study11/","excerpt":"","text":"@RequestBody 注解@RequestBody接收的参数是来自请求体中。一般用于处理非 Content-Type: application/x-www-form-urlencoded编码格式的数据，比如：application/json、application/xml等类型的数据。 @RequestBody并不实用于GET请求，GET请求没有HttpEntity。 POST请求，通过HttpEntity传值，必须要指定数据类型Content-Type的值。 @RequestParam 注解@RequestParam接收的参数是来自HTTP请求体或请求url的QueryString中。 RequestParam可以接受简单类型的属性，也可以接受对象类型。 @RequestParam有三个配置参数 required 表示是否必须，默认为 true，必须。 defaultValue 可设置请求参数的默认值。 value 为接收url的参数名（相当于key值），如前端传递数据{id:123},value值应为id。 @RequestParam用来处理 Content-Type 为 application/x-www-form-urlencoded 编码的内容，Content-Type默认为该属性，也可以接收​​​​​​​application/json。 POST请求 @RequestBody用于JSON字符串部分 @RequestParam用于请求参数部分(url中?后参数)，Content-Type为form-data、x-www-form-urlencoded、form-data、x-www-form-urlencoded均可 从content-type方面总结 form-data、x-www-form-urlencoded：不可以用@RequestBody；可以用@RequestParam。 application/json：json字符串部分可以用@RequestBody；url中的?后面参数可以用@RequestParam。 注解方式 @RequestBody12345(@RequestBody Map map)(@RequestBody Object object)Content-Type为application&#x2F;json时候可用form-data、x-www-form-urlencoded时候不可用 @RequestParam123456789101112(@RequestParam Map map)Content-Type为application&#x2F;json时候，json字符串部分不可用，url中的?后面添加参数即可用，form-data、x-www-form-urlencoded时候可用，但是要将Headers里的Content-Type删掉(@RequestParam String waterEleId,@RequestParam String enterpriseName)Content-Type为application&#x2F;json时候，json字符串部分不可用，url中的?后面添加参数即可用form-data、x-www-form-urlencoded时候可用，且参数可以没有顺序，但是要将Headers里的Content-Type删掉(@RequestParam Object object)Content-Type为不管application&#x2F;json、form-data、x-www-form-urlencoded都不可用 GET请求 GET请求中不可以使用@RequestBody 在url中的?后面添加参数可使用(@RequestParam Map map)和(@RequestParam String waterEleId,@RequestParam String enterpriseName)两种方式 GET请求中不可以使用(@RequestParam Object object)方式","categories":[],"tags":[]},{"title":"应用开发之环境搭建","slug":"study10","date":"2020-11-16T04:29:23.000Z","updated":"2020-11-16T10:06:44.232Z","comments":true,"path":"2020/11/16/study10/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/11/16/study10/","excerpt":"环境安装 Java开发工具JDK下载下载地址 根据需求下载 环境变量配置 右击“我的电脑”→“属性”→“高级系统设置”→“高级”→“环境变量”。 新建系统变量“JAVA_HOME”，变量值为JDK安装路径。 新建系统变量“CLASSPATH”，变量值为“.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;”。 编辑系统变量“Path”，添加变量值“%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;”。","text":"环境安装 Java开发工具JDK下载下载地址 根据需求下载 环境变量配置 右击“我的电脑”→“属性”→“高级系统设置”→“高级”→“环境变量”。 新建系统变量“JAVA_HOME”，变量值为JDK安装路径。 新建系统变量“CLASSPATH”，变量值为“.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;”。 编辑系统变量“Path”，添加变量值“%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;”。 Mysql安装下载地址 下载安装包安装即可 Android开发环境搭建 安装JDK，同Java 点击页面顶部菜单栏Android studio即可下载安装包 SDK下载下载地址 Go环境安装下载地址 根据需求下载 环境变量配置 例如Go安装地址“C:/Go”，编辑环境变量PATH，添加“C:/Go/bin”。 开发工具 IntelliJ IDEA下载地址 进入官网点击 Download 进入，分两个版本Ultimate和Community根据自己需求下载，Ultimate版功能相对完善。 安装根据教程安装即可 Android studio下载地址 下载完成根据教程安装即可 VS Code下载地址 下载完成根据教程安装即可","categories":[],"tags":[]},{"title":"Android之饼图","slug":"study8","date":"2020-11-09T11:46:51.000Z","updated":"2020-11-16T13:01:26.203Z","comments":true,"path":"2020/11/09/study8/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/11/09/study8/","excerpt":"任务 Android端将获取数据中浏览总量前10的数据以饼图的形式展示。 解决 在项目工程Gradle123repositories &#123; maven &#123; url &#39;https:&#x2F;&#x2F;jitpack.io&#39; &#125;&#125; 在组件Gradle123dependencies &#123; implementation &#39;com.github.PhilJay:MPAndroidChart:v3.1.0-alpha&#39;&#125; 布局123456789101112&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:orientation&#x3D;&quot;vertical&quot;&gt; &lt;com.github.mikephil.charting.charts.PieChart android:id&#x3D;&quot;@+id&#x2F;pieChart&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; &#x2F;&gt;&lt;&#x2F;LinearLayout&gt;","text":"任务 Android端将获取数据中浏览总量前10的数据以饼图的形式展示。 解决 在项目工程Gradle123repositories &#123; maven &#123; url &#39;https:&#x2F;&#x2F;jitpack.io&#39; &#125;&#125; 在组件Gradle123dependencies &#123; implementation &#39;com.github.PhilJay:MPAndroidChart:v3.1.0-alpha&#39;&#125; 布局123456789101112&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:orientation&#x3D;&quot;vertical&quot;&gt; &lt;com.github.mikephil.charting.charts.PieChart android:id&#x3D;&quot;@+id&#x2F;pieChart&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; &#x2F;&gt;&lt;&#x2F;LinearLayout&gt; 主要代码12345678910111213141516171819202122232425262728293031323334final PieChart pieChart &#x3D; (PieChart) findViewById(R.id.pieChart); pieChart.setNoDataText(&quot;没有数据&quot;); final PieDataSet pieDataSet &#x3D; new PieDataSet(list,&quot;&quot;);&#x2F;&#x2F;list为饼图数据对应值和解释，类型PieEntry集合 &#x2F;&#x2F;配置饼图颜色，一般有多少项数据，就配置多少个颜色的，少的话会复用最后一个颜色 pieDataSet.setColors(Color.parseColor(&quot;#feb64d&quot;), Color.parseColor(&quot;#ff7c7c&quot;), Color.parseColor(&quot;#9287e7&quot;), Color.parseColor(&quot;#6200ee&quot;), Color.parseColor(&quot;#03dac5&quot;), Color.parseColor(&quot;#ff07cb&quot;), Color.parseColor(&quot;#ffeb61&quot;), Color.parseColor(&quot;#ffacba&quot;), Color.parseColor(&quot;#ff0000&quot;), Color.parseColor(&quot;#00ff00&quot;)); PieData pieData &#x3D; new PieData(pieDataSet); pieChart.setData(pieData); &#x2F;&#x2F;设置值得颜色 pieData.setValueTextColor(Color.parseColor(&quot;#000000&quot;)); &#x2F;&#x2F;设置值字体大小 pieData.setValueTextSize(12); Description description &#x3D; new Description(); description.setText(&quot;&quot;);&#x2F;&#x2F;定义饼图说明 Legend legend &#x3D; pieChart.getLegend();&#x2F;&#x2F;设置图例 legend.setVerticalAlignment(Legend.LegendVerticalAlignment.BOTTOM);&#x2F;&#x2F;图例位置 legend.setFormSize(12f);&#x2F;&#x2F;图例大小 legend.setTextSize(14f);&#x2F;&#x2F;图例说明字体大小 legend.setWordWrapEnabled(true); pieChart.setDescription(description); pieChart.setHoleRadius(0); pieChart.setTransparentCircleAlpha(0); pieChart.setDrawEntryLabels(false); pieChart.animateXY(1000,1000);&#x2F;&#x2F;动画效果 pieChart.invalidate();","categories":[],"tags":[]},{"title":"Android之柱形图和散点图","slug":"study9","date":"2020-11-06T12:37:58.000Z","updated":"2020-11-16T13:01:37.087Z","comments":true,"path":"2020/11/06/study9/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/11/06/study9/","excerpt":"","text":"任务 Android端将获取数据中浏览总量前10的数据以柱形图的形式展示。 解决 主要代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#x2F;&#x2F;初始化private void initView() &#123; mBarChart &#x3D; (BarChart) findViewById(R.id.mBarChart); mBarChart.getDescription().setEnabled(false); mBarChart.setMaxVisibleValueCount(20000000);&#x2F;&#x2F;Y轴最大值 mBarChart.setPinchZoom(false);&#x2F;&#x2F;设置true支持两个指头向X、Y轴的缩放，如果为false，只能支持X或者Y轴的当方向缩放 mBarChart.setDrawBarShadow(false); mBarChart.setDrawGridBackground(false);&#x2F;&#x2F;设置背景是否网格显示 XAxis xAxis &#x3D; mBarChart.getXAxis(); xAxis.setPosition(XAxis.XAxisPosition.BOTTOM);&#x2F;&#x2F;X轴位置 xAxis.setDrawGridLines(false); mBarChart.getAxisLeft().setDrawGridLines(false);&#x2F;&#x2F;设置是否绘制网格线 mBarChart.getAxisRight().setEnabled(false);&#x2F;&#x2F;右侧Y轴显示，true显示，false不显示 mBarChart.animateY(2500); mBarChart.getLegend().setEnabled(false); &#x2F;&#x2F;设置能否缩放 mBarChart.setScaleXEnabled(false); mBarChart.setScaleYEnabled(false); mBarChart.setDragEnabled(false); initData();&#125;&#x2F;&#x2F;设置数据private void setData() &#123; BarDataSet set1; if (mBarChart.getData() !&#x3D; null &amp;&amp; mBarChart.getData().getDataSetCount() &gt; 0) &#123; set1 &#x3D; (BarDataSet) mBarChart.getData().getDataSetByIndex(0); set1.setValues(yVals1); mBarChart.getData().notifyDataChanged(); mBarChart.notifyDataSetChanged(); &#125; else &#123; set1 &#x3D; new BarDataSet(yVals1, &quot;日期设置&quot;);&#x2F;&#x2F;yVals1为Y值 &#x2F;&#x2F;设置多彩 也可以单一颜色 set1.setColors(ColorTemplate.VORDIPLOM_COLORS); set1.setDrawValues(false); set1.setBarBorderWidth(0.5f); ArrayList&lt;IBarDataSet&gt; dataSets &#x3D; new ArrayList&lt;IBarDataSet&gt;(); dataSets.add(set1); BarData data &#x3D; new BarData(dataSets); data.setValueTextSize(12f); mBarChart.setData(data); mBarChart.setFitBars(true); &#125; mBarChart.invalidate();&#125; 布局12345678910111213&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:orientation&#x3D;&quot;vertical&quot;&gt; &lt;com.github.mikephil.charting.charts.BarChart android:id&#x3D;&quot;@+id&#x2F;mBarChart&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;0dp&quot; android:layout_weight&#x3D;&quot;1&quot;&#x2F;&gt;&lt;&#x2F;LinearLayout&gt; Android端将获取数据中浏览总量前3的数据以散点图的形式展示。 解决 主要代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&#x2F;&#x2F;初始化Viewprivate void initView() &#123; &#x2F;&#x2F;基本控件 btn_show_values &#x3D; (Button) findViewById(R.id.btn_show_values); btn_show_values.setOnClickListener(this); btn_anim_x &#x3D; (Button) findViewById(R.id.btn_anim_x); btn_anim_x.setOnClickListener(this); btn_anim_y &#x3D; (Button) findViewById(R.id.btn_anim_y); btn_anim_y.setOnClickListener(this); btn_anim_xy &#x3D; (Button) findViewById(R.id.btn_anim_xy); btn_anim_xy.setOnClickListener(this); &#x2F;&#x2F;散点图 mScatterChart &#x3D; (ScatterChart) findViewById(R.id.mScatterChart); mScatterChart.getDescription().setEnabled(false); mScatterChart.setOnChartValueSelectedListener(this); mScatterChart.setDrawGridBackground(false); mScatterChart.setTouchEnabled(true); mScatterChart.setMaxHighlightDistance(10f); &#x2F;&#x2F; 支持缩放和拖动 mScatterChart.setDragEnabled(true); mScatterChart.setScaleEnabled(true); mScatterChart.setMaxVisibleValueCount(5000000);&#x2F;&#x2F;Y轴显示最大值 mScatterChart.getAxisLeft().setAxisMinimum(2000000);&#x2F;&#x2F;Y轴显示最小值 mScatterChart.getAxisLeft().setDrawGridLines(false); mScatterChart.setPinchZoom(true); Legend l &#x3D; mScatterChart.getLegend(); l.setVerticalAlignment(Legend.LegendVerticalAlignment.TOP); l.setHorizontalAlignment(Legend.LegendHorizontalAlignment.CENTER); l.setOrientation(Legend.LegendOrientation.VERTICAL); l.setDrawInside(false); l.setXOffset(5f); mScatterChart.getAxisRight().setEnabled(false); XAxis xl &#x3D; mScatterChart.getXAxis(); xl.setDrawGridLines(false); xl.setPosition(XAxis.XAxisPosition.BOTTOM); initData();&#125;&#x2F;&#x2F;设置数据private void setData() &#123; &#x2F;&#x2F;创建一个数据集,并给它一个类型 ScatterDataSet set1 &#x3D; new ScatterDataSet(yVals1, title[0]);&#x2F;&#x2F;yVals1为浏览量第一Y值 set1.setScatterShape(ScatterChart.ScatterShape.SQUARE); &#x2F;&#x2F;设置颜色 set1.setColor(ColorTemplate.COLORFUL_COLORS[0]); set1.setDrawValues(false); ScatterDataSet set2 &#x3D; new ScatterDataSet(yVals2, title[1]);&#x2F;&#x2F;yVals2为浏览量第二Y值 set2.setScatterShape(ScatterChart.ScatterShape.CIRCLE); set2.setScatterShapeHoleColor(ColorTemplate.COLORFUL_COLORS[3]); set2.setScatterShapeHoleRadius(3f); set2.setColor(ColorTemplate.COLORFUL_COLORS[1]); set2.setDrawValues(false); ScatterDataSet set3 &#x3D; new ScatterDataSet(yVals3, title[2]);&#x2F;&#x2F;yVals3为浏览量第三Y值 set3.setShapeRenderer(new CircleShapeRenderer()); set3.setColor(ColorTemplate.COLORFUL_COLORS[2]); set3.setDrawValues(false); set1.setScatterShapeSize(12f); set2.setScatterShapeSize(12f); set3.setScatterShapeSize(12f); ArrayList&lt;IScatterDataSet&gt; dataSets &#x3D; new ArrayList&lt;IScatterDataSet&gt;(); dataSets.add(set1); dataSets.add(set2); dataSets.add(set3); &#x2F;&#x2F;创建一个数据集的数据对象 ScatterData data &#x3D; new ScatterData(dataSets); data.setValueTextSize(12f); mScatterChart.setData(data); mScatterChart.invalidate();&#125; 布局12345678910111213&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:orientation&#x3D;&quot;vertical&quot;&gt; &lt;com.github.mikephil.charting.charts.ScatterChart android:id&#x3D;&quot;@+id&#x2F;mScatterChart&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;0dp&quot; android:layout_weight&#x3D;&quot;1&quot; &#x2F;&gt;&lt;&#x2F;LinearLayout&gt;","categories":[],"tags":[]},{"title":"Android之曲线图","slug":"study7","date":"2020-11-04T11:02:22.000Z","updated":"2020-11-16T13:01:23.399Z","comments":true,"path":"2020/11/04/study7/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/11/04/study7/","excerpt":"任务 Android端将获取数据中标题相同的数据以曲线图的形式展示。 解决 思路：根据点的数量将Canvas等分，等分后先绘制图表的所有横轴和纵轴。再将数据转化为点坐标，绘制到屏幕上，最后将相邻两点连成线即可。自定义曲线图类","text":"任务 Android端将获取数据中标题相同的数据以曲线图的形式展示。 解决 思路：根据点的数量将Canvas等分，等分后先绘制图表的所有横轴和纵轴。再将数据转化为点坐标，绘制到屏幕上，最后将相邻两点连成线即可。自定义曲线图类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227public class LineGraphicView extends View &#123; &#x2F;** * 公共部分 *&#x2F; private static final int CIRCLE_SIZE &#x3D; 10; private static enum Linestyle &#123; Line, Curve &#125; private Context mContext; private Paint mPaint; private Resources res; private DisplayMetrics dm; &#x2F;** * data *&#x2F; private Linestyle mStyle &#x3D; Linestyle.Curve; private int canvasHeight; private int canvasWidth; private int bheight &#x3D; 0; private int blwidh; private boolean isMeasure &#x3D; true; &#x2F;** * Y轴最大值 *&#x2F; private int maxValue; &#x2F;** * Y轴间距值 *&#x2F; private int averageValue; private int marginTop &#x3D; 20; private int marginBottom &#x3D; 40; &#x2F;** * 曲线上总点数 *&#x2F; private Point[] mPoints; &#x2F;** * 纵坐标值 *&#x2F; private ArrayList&lt;Double&gt; yRawData; &#x2F;** * 横坐标值 *&#x2F; private ArrayList&lt;String&gt; xRawDatas; private ArrayList&lt;Integer&gt; xList &#x3D; new ArrayList&lt;Integer&gt;();&#x2F;&#x2F; 记录每个x的值 private int spacingHeight; public LineGraphicView(Context context) &#123; this(context, null); &#125; public LineGraphicView(Context context, AttributeSet attrs) &#123; super(context, attrs); this.mContext &#x3D; context; initView(); &#125; private void initView() &#123; this.res &#x3D; mContext.getResources(); this.mPaint &#x3D; new Paint(Paint.ANTI_ALIAS_FLAG); dm &#x3D; new DisplayMetrics(); WindowManager wm &#x3D; (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE); wm.getDefaultDisplay().getMetrics(dm); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; if (isMeasure) &#123; this.canvasHeight &#x3D; getHeight(); this.canvasWidth &#x3D; getWidth(); if (bheight &#x3D;&#x3D; 0) bheight &#x3D; (int) (canvasHeight - marginBottom); blwidh &#x3D; dip2px(30); isMeasure &#x3D; false; &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; mPaint.setColor(res.getColor(R.color.color)); drawAllXLine(canvas); &#x2F;&#x2F; 画直线（纵向） drawAllYLine(canvas); &#x2F;&#x2F; 点的操作设置 mPoints &#x3D; getPoints(); mPaint.setColor(res.getColor(R.color.color)); mPaint.setStrokeWidth(dip2px(2.5f)); mPaint.setStyle(Style.STROKE); if (mStyle &#x3D;&#x3D; Linestyle.Curve) &#123; drawScrollLine(canvas); &#125; else &#123; drawLine(canvas); &#125; mPaint.setStyle(Style.FILL); for (int i &#x3D; 0; i &lt; mPoints.length; i++) &#123; canvas.drawCircle(mPoints[i].x, mPoints[i].y, CIRCLE_SIZE &#x2F; 2, mPaint); &#125; &#125; &#x2F;** * 画所有横向表格，包括X轴 *&#x2F; private void drawAllXLine(Canvas canvas) &#123; for (int i &#x3D; 0; i &lt; spacingHeight + 1; i++) &#123; if (spacingHeight !&#x3D; 0) &#123; canvas.drawLine(blwidh, bheight - (bheight &#x2F; spacingHeight) * i + marginTop, (canvasWidth - blwidh), bheight - (bheight &#x2F; spacingHeight) * i + marginTop, mPaint);&#x2F;&#x2F; Y坐标 drawText(String.valueOf(averageValue * i), blwidh &#x2F; 2, bheight - (bheight &#x2F; spacingHeight) * i + marginTop, canvas); &#125; &#125; &#125; &#x2F;** * 画所有纵向表格，包括Y轴 *&#x2F; private void drawAllYLine(Canvas canvas) &#123; if (yRawData !&#x3D; null) &#123; for (int i &#x3D; 0; i &lt; yRawData.size(); i++) &#123; xList.add(blwidh + (canvasWidth - blwidh) &#x2F; yRawData.size() * i); canvas.drawLine(blwidh + (canvasWidth - blwidh) &#x2F; yRawData.size() * i, marginTop, blwidh + (canvasWidth - blwidh) &#x2F; yRawData.size() * i, bheight + marginTop, mPaint); drawText(xRawDatas.get(i), blwidh + (canvasWidth - blwidh) &#x2F; yRawData.size() * i, bheight + dip2px(26), canvas);&#x2F;&#x2F; X坐标 &#125; &#125; &#125; private void drawScrollLine(Canvas canvas) &#123; Point startp &#x3D; new Point(); Point endp &#x3D; new Point(); for (int i &#x3D; 0; i &lt; mPoints.length - 1; i++) &#123; startp &#x3D; mPoints[i]; endp &#x3D; mPoints[i + 1]; int wt &#x3D; (startp.x + endp.x) &#x2F; 2; Point p3 &#x3D; new Point(); Point p4 &#x3D; new Point(); p3.y &#x3D; startp.y; p3.x &#x3D; wt; p4.y &#x3D; endp.y; p4.x &#x3D; wt; Path path &#x3D; new Path(); path.moveTo(startp.x, startp.y); path.cubicTo(p3.x, p3.y, p4.x, p4.y, endp.x, endp.y); canvas.drawPath(path, mPaint); &#125; &#125; private void drawLine(Canvas canvas) &#123; Point startp &#x3D; new Point(); Point endp &#x3D; new Point(); for (int i &#x3D; 0; i &lt; mPoints.length - 1; i++) &#123; startp &#x3D; mPoints[i]; endp &#x3D; mPoints[i + 1]; canvas.drawLine(startp.x, startp.y, endp.x, endp.y, mPaint); &#125; &#125; private void drawText(String text, int x, int y, Canvas canvas) &#123; Paint p &#x3D; new Paint(Paint.ANTI_ALIAS_FLAG); p.setTextSize(dip2px(12)); p.setColor(res.getColor(R.color.colors)); p.setTextAlign(Paint.Align.LEFT); canvas.drawText(text, x, y, p); &#125; private Point[] getPoints() &#123; if (yRawData !&#x3D; null) &#123; Point[] points &#x3D; new Point[yRawData.size()]; for (int i &#x3D; 0; i &lt; yRawData.size(); i++) &#123; int ph &#x3D; bheight - (int) (bheight * (yRawData.get(i) &#x2F; maxValue)); points[i] &#x3D; new Point(xList.get(i), ph + marginTop); &#125; return points; &#125; return new Point[0]; &#125; public void setData(ArrayList&lt;Double&gt; yRawData, ArrayList&lt;String&gt; xRawData, int maxValue, int averageValue,int spacingHeight) &#123; this.maxValue &#x3D; maxValue; this.averageValue &#x3D; averageValue; this.mPoints &#x3D; new Point[yRawData.size()]; this.xRawDatas &#x3D; xRawData; this.yRawData &#x3D; yRawData; this.spacingHeight &#x3D; spacingHeight; &#125; public void setTotalvalue(int maxValue) &#123; this.maxValue &#x3D; maxValue; &#125; public void setPjvalue(int averageValue) &#123; this.averageValue &#x3D; averageValue; &#125; public void setMargint(int marginTop) &#123; this.marginTop &#x3D; marginTop; &#125; public void setMarginb(int marginBottom) &#123; this.marginBottom &#x3D; marginBottom; &#125; public void setMstyle(Linestyle mStyle) &#123; this.mStyle &#x3D; mStyle; &#125; public void setBheight(int bheight) &#123; this.bheight &#x3D; bheight; &#125; &#x2F;** * 根据手机的分辨率从 dp 的单位 转成为 px(像素) *&#x2F; private int dip2px(float dpValue) &#123; return (int) (dpValue * dm.density + 0.5f); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private void sendRequestWithOkHttp() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Intent intent &#x3D; getIntent(); String title &#x3D; intent.getStringExtra(&quot;title&quot;); &#x2F;&#x2F;接收标题 OkHttpClient client &#x3D; new OkHttpClient(); RequestBody requestBody &#x3D; new FormBody.Builder() .add(&quot;title&quot;,title) .build(); Request request &#x3D; new Request.Builder() .url(&quot;http:&#x2F;&#x2F;10.0.2.2:8080&#x2F;api&#x2F;weibo&quot;) .post(requestBody) .build(); Response response &#x3D; client.newCall(request).execute(); String responseData &#x3D; response.body().string(); showRepose(responseData); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start();&#125;private void showRepose(final String response) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; try &#123; tu &#x3D; (LineGraphicView) findViewById(R.id.line_graphic); JSONArray jsonArray &#x3D; new JSONArray(response); String title &#x3D; null; for (int i &#x3D; 0;i &lt; jsonArray.length(); i++)&#123; JSONObject jsonObject &#x3D; jsonArray.getJSONObject(i); title &#x3D; jsonObject.getString(&quot;title&quot;); String view &#x3D; jsonObject.getString(&quot;view&quot;); String time &#x3D; jsonObject.getString(&quot;time&quot;); yList.add(Double.parseDouble(view)); xRawDatas.add(time); if (oldMax &gt;&#x3D; newMax) &#123; newMax &#x3D; oldMax; oldMax &#x3D; Integer.parseInt(view); averageValue &#x3D; newMax&#x2F;5; &#125; &#125; textView &#x3D; (TextView) findViewById(R.id.title); textView.setText(title); tu.setData(yList,xRawDatas,newMax * 2,averageValue,5); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;);&#125;","categories":[],"tags":[]},{"title":"Android之简单分页","slug":"study6","date":"2020-11-03T12:46:46.000Z","updated":"2020-11-16T13:02:11.682Z","comments":true,"path":"2020/11/03/study6/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/11/03/study6/","excerpt":"任务 Android端对数据进行简单的分页。 主要代码在页面中添加下列布局1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;LinearLayout android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_gravity&#x3D;&quot;center&quot; android:orientation&#x3D;&quot;horizontal&quot;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;up&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_gravity&#x3D;&quot;center_vertical&quot; android:text&#x3D;&quot;上一页&quot; &#x2F;&gt; &lt;TextView android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;第&quot; android:textSize&#x3D;&quot;18sp&quot;&#x2F;&gt; &lt;EditText android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:id&#x3D;&quot;@+id&#x2F;edit_text&quot;&#x2F;&gt; &lt;TextView android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;页&quot; android:textSize&#x3D;&quot;18sp&quot;&#x2F;&gt; &lt;Button android:layout_width&#x3D;&quot;50dp&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:id&#x3D;&quot;@+id&#x2F;go&quot; android:text&#x3D;&quot;go&quot;&#x2F;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;down&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_gravity&#x3D;&quot;center_vertical&quot; android:text&#x3D;&quot;下一页&quot; &#x2F;&gt;&lt;&#x2F;LinearLayout&gt;","text":"任务 Android端对数据进行简单的分页。 主要代码在页面中添加下列布局1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;LinearLayout android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_gravity&#x3D;&quot;center&quot; android:orientation&#x3D;&quot;horizontal&quot;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;up&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_gravity&#x3D;&quot;center_vertical&quot; android:text&#x3D;&quot;上一页&quot; &#x2F;&gt; &lt;TextView android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;第&quot; android:textSize&#x3D;&quot;18sp&quot;&#x2F;&gt; &lt;EditText android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:id&#x3D;&quot;@+id&#x2F;edit_text&quot;&#x2F;&gt; &lt;TextView android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;页&quot; android:textSize&#x3D;&quot;18sp&quot;&#x2F;&gt; &lt;Button android:layout_width&#x3D;&quot;50dp&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:id&#x3D;&quot;@+id&#x2F;go&quot; android:text&#x3D;&quot;go&quot;&#x2F;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;down&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:layout_gravity&#x3D;&quot;center_vertical&quot; android:text&#x3D;&quot;下一页&quot; &#x2F;&gt;&lt;&#x2F;LinearLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970up &#x3D; (Button) findViewById(R.id.up);up.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (count !&#x3D; 1) &#123; judge &#x3D; false; initData(count - 2); &#125; &#125;&#125;);down &#x3D; (Button) findViewById(R.id.down);down.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; try &#123; judge &#x3D; true; Intent intent &#x3D; getIntent(); String jsonData &#x3D; intent.getStringExtra(&quot;list&quot;); JSONArray jsonArray &#x3D; new JSONArray(jsonData); if (count &lt; (Integer.parseInt(String.valueOf(jsonArray.length())) &#x2F; 25) + 1) &#123; initData(count); &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125;&#125;);go &#x3D; (Button) findViewById(R.id.go);go.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; count &#x3D; Integer.parseInt(editText.getText().toString()) - 1; initData(count); &#125;&#125;);private void initData(int num) &#123; try &#123; list.clear(); Intent intent &#x3D; getIntent(); String jsonData &#x3D; intent.getStringExtra(&quot;list&quot;); JSONArray jsonArray &#x3D; new JSONArray(jsonData); oldCount &#x3D; num * 25; if (judge) &#123; count &#x3D; count + 1; &#125; else &#123; count &#x3D; count - 1; &#125; editText &#x3D; (EditText) findViewById(R.id.edit_text); String page &#x3D; String.valueOf(count); editText.setText(page); for (num &#x3D; oldCount; num &lt; oldCount + 25; num++) &#123; if (num &lt; jsonArray.length()) &#123; JSONObject jsonObject &#x3D; jsonArray.getJSONObject(num); String id &#x3D; jsonObject.getString(&quot;id&quot;); String rank &#x3D; jsonObject.getString(&quot;rank&quot;); String title &#x3D; jsonObject.getString(&quot;title&quot;); String view &#x3D; jsonObject.getString(&quot;view&quot;); String time &#x3D; jsonObject.getString(&quot;time&quot;); Weibo weibo &#x3D; new Weibo(id, rank, title, view, time); list.add(weibo); &#125; &#125; adapter &#x3D; new WeiboAdapter(ListViewActivity.this, R.layout.list_item, list); listView &#x3D; (ListView) findViewById(R.id.list_view1); listView.setAdapter(adapter); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125;&#125;","categories":[],"tags":[]},{"title":"Android之表格","slug":"study5","date":"2020-10-29T12:39:40.000Z","updated":"2020-11-16T13:02:30.784Z","comments":true,"path":"2020/10/29/study5/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/10/29/study5/","excerpt":"","text":"任务 Android运用表格展示数据。 过程 在gradle中添加：implementation ‘com.hlq:tableview:1.1.0’ 项目根目录下的build.gradle中添加1234567allprojects &#123; repositories &#123; google() jcenter() maven &#123;url &quot;https:&#x2F;&#x2F;dl.bintray.com&#x2F;huanglinqing&#x2F;maven&#x2F;&quot;&#125; &#125;&#125; 布局123456&lt;hlq.tablbeview.TableView android:id&#x3D;&quot;@+id&#x2F;tabview&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; app:colnum&#x3D;&quot;4&quot; app:rownum&#x3D;&quot;1&quot; &#x2F;&gt; 12345678910111213141516Intent intent &#x3D; getIntent();String jsonData &#x3D; intent.getStringExtra(&quot;list&quot;); &#x2F;&#x2F;接收上一个页面传递数据JSONArray jsonArray &#x3D; new JSONArray(jsonData);String[][] data &#x3D; new String[jsonArray.length()][4];for (int i &#x3D; 0; i &lt; jsonArray.length(); i++) &#123; JSONObject jsonObject &#x3D; jsonArray.getJSONObject(i); String id &#x3D; jsonObject.getString(&quot;id&quot;); String rank &#x3D; jsonObject.getString(&quot;rank&quot;); String title &#x3D; jsonObject.getString(&quot;title&quot;); String view &#x3D; jsonObject.getString(&quot;view&quot;); data[num][0] &#x3D; id; data[num][1] &#x3D; rank; data[num][2] &#x3D; title; data[num][3] &#x3D; view; tableView.setTableContent(data[i]);&#125;","categories":[],"tags":[]},{"title":"Android与后端的交互","slug":"study4","date":"2020-10-28T12:16:28.000Z","updated":"2020-11-16T13:03:17.496Z","comments":true,"path":"2020/10/28/study4/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/10/28/study4/","excerpt":"问题 Android如何运用okhttp传递json数据到服务器端。 解决123456JSONObject json &#x3D; new JSONObject();RequestBody requestBody &#x3D; RequestBody.create(JSON, json.toString());Request request &#x3D; new Request.Builder() .url(&quot;http:&#x2F;&#x2F;10.0.2.2:8080&#x2F;weibo&#x2F;insert&quot;) .post(requestBody) .build(); 任务 完成Android端与服务器端的数据传递接收，Android展示接收到数据。 主要代码 MainActivity.java12345678910111213141516171819202122232425262728293031private void sendRequestWithOkHttp() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; OkHttpClient client &#x3D; new OkHttpClient(); RequestBody requestBody &#x3D; new FormBody.Builder() .build(); Request request &#x3D; new Request.Builder() .url(&quot;http:&#x2F;&#x2F;10.0.2.2:8080&#x2F;weibo&quot;) .post(requestBody) .build(); Response response &#x3D; client.newCall(request).execute(); String responseData &#x3D; response.body().string(); showRepose(responseData); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start();&#125;private void showRepose(final String response) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; Intent intent &#x3D; new Intent(MainActivity.this, ListViewActivity.class); intent.putExtra(&quot;list&quot;, response); startActivity(intent); &#125; &#125;);&#125;","text":"问题 Android如何运用okhttp传递json数据到服务器端。 解决123456JSONObject json &#x3D; new JSONObject();RequestBody requestBody &#x3D; RequestBody.create(JSON, json.toString());Request request &#x3D; new Request.Builder() .url(&quot;http:&#x2F;&#x2F;10.0.2.2:8080&#x2F;weibo&#x2F;insert&quot;) .post(requestBody) .build(); 任务 完成Android端与服务器端的数据传递接收，Android展示接收到数据。 主要代码 MainActivity.java12345678910111213141516171819202122232425262728293031private void sendRequestWithOkHttp() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; OkHttpClient client &#x3D; new OkHttpClient(); RequestBody requestBody &#x3D; new FormBody.Builder() .build(); Request request &#x3D; new Request.Builder() .url(&quot;http:&#x2F;&#x2F;10.0.2.2:8080&#x2F;weibo&quot;) .post(requestBody) .build(); Response response &#x3D; client.newCall(request).execute(); String responseData &#x3D; response.body().string(); showRepose(responseData); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start();&#125;private void showRepose(final String response) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; Intent intent &#x3D; new Intent(MainActivity.this, ListViewActivity.class); intent.putExtra(&quot;list&quot;, response); startActivity(intent); &#125; &#125;);&#125; ListViewActivity.java1234567891011121314151617Intent intent &#x3D; getIntent();String jsonData &#x3D; intent.getStringExtra(&quot;list&quot;);JSONArray jsonArray &#x3D; new JSONArray(jsonData);for (int i &#x3D; 0; i &lt; jsonArray.length(); i++) &#123; JSONObject jsonObject &#x3D; jsonArray.getJSONObject(num); String id &#x3D; jsonObject.getString(&quot;id&quot;); String rank &#x3D; jsonObject.getString(&quot;rank&quot;); String title &#x3D; jsonObject.getString(&quot;title&quot;); String view &#x3D; jsonObject.getString(&quot;view&quot;); String time &#x3D; jsonObject.getString(&quot;time&quot;); Weibo weibo &#x3D; new Weibo(id, rank, title, view, time); list.add(weibo);&#125;adapter &#x3D; new WeiboAdapter(ListViewActivity.this, R.layout.list_item, list);listView &#x3D; (ListView) findViewById(R.id.list_view1);listView.setAdapter(adapter); 123456789101112&lt;ScrollView android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:fillViewport&#x3D;&quot;true&quot; android:scrollbars&#x3D;&quot;none&quot;&gt; &lt;ListView android:id&#x3D;&quot;@+id&#x2F;list_view1&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;wrap_content&quot; &#x2F;&gt;&lt;&#x2F;ScrollView&gt;","categories":[],"tags":[]},{"title":"Js之曲线图","slug":"study3","date":"2020-10-27T11:25:36.000Z","updated":"2020-11-16T13:03:45.334Z","comments":true,"path":"2020/10/27/study3/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/10/27/study3/","excerpt":"","text":"任务 js端运用echart将获取数据中标题相同的数据以曲线图的形式展示。 主要代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;script&gt; var dom &#x3D; document.getElementById(&quot;container&quot;); var myChart &#x3D; echarts.init(dom); var app &#x3D; &#123;&#125;; option &#x3D; null; option &#x3D; &#123; title: &#123; text: &#39;折线图堆叠&#39; &#125;, tooltip: &#123; trigger: &#39;axis&#39; &#125;, legend: &#123; data: arr &#125;, grid: &#123; left: &#39;3%&#39;, right: &#39;4%&#39;, bottom: &#39;3%&#39;, containLabel: true &#125;, toolbox: &#123; feature: &#123; saveAsImage: &#123;&#125; &#125; &#125;, xAxis: &#123; type: &#39;category&#39;, boundaryGap: false, data: xArr &#125;, yAxis: &#123; type: &#39;value&#39; &#125;, series: [ &#123; name: &#39;邮件营销&#39;, type: &#39;line&#39;, stack: &#39;总量&#39;, data: yArr, smooth:true &#125; ] &#125;; if (option &amp;&amp; typeof option &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123; myChart.setOption(option, true); &#125; $(&#39;#container&#39;).dialog(&#39;open&#39;).dialog(&#39;setTitle&#39;,&#39;曲线图&#39;)&lt;&#x2F;script&gt;","categories":[],"tags":[]},{"title":"Js之表格","slug":"study2","date":"2020-10-26T09:36:22.000Z","updated":"2020-11-16T13:04:41.676Z","comments":true,"path":"2020/10/26/study2/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/10/26/study2/","excerpt":"后端遇到问题 传参数，后台@RequestBody接收实体，报错：Content type ‘application/x-www-form-urlencoded;charset=UTF-8’ not supported 原因及解决方法 在ajax语句中添加如下代码1234 $.ajax(&#123; data: JSON.stringify(json格式数据),contentType:&quot;application&#x2F;json&quot;, &#125;); 原因：@RequestBody注解要求的必须是json格式的字符串才能注入参数 传参数，后台@RequestBody接收实体，报错：Required request body is missing，@RequestBody对象为空 原因及解决方法配置@RequestBody注解：1@RequestBody （required&#x3D;false） 任务 js端与服务器端完成数据传递接收，js端以表格形式显示接受到服务器端数据，实现简单的增删改查功能。 主要代码逻辑 增删改","text":"后端遇到问题 传参数，后台@RequestBody接收实体，报错：Content type ‘application/x-www-form-urlencoded;charset=UTF-8’ not supported 原因及解决方法 在ajax语句中添加如下代码1234 $.ajax(&#123; data: JSON.stringify(json格式数据),contentType:&quot;application&#x2F;json&quot;, &#125;); 原因：@RequestBody注解要求的必须是json格式的字符串才能注入参数 传参数，后台@RequestBody接收实体，报错：Required request body is missing，@RequestBody对象为空 原因及解决方法配置@RequestBody注解：1@RequestBody （required&#x3D;false） 任务 js端与服务器端完成数据传递接收，js端以表格形式显示接受到服务器端数据，实现简单的增删改查功能。 主要代码逻辑 增删改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;var url;var redata;function newUser()&#123; $(&#39;#dlg&#39;).dialog(&#39;open&#39;).dialog(&#39;setTitle&#39;,&#39;New&#39;); $(&#39;#fm&#39;).form(&#39;clear&#39;); url &#x3D; &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;weibo&#x2F;insert&#39;;&#125;function editUser()&#123; var row &#x3D; $(&#39;#dg&#39;).datagrid(&#39;getSelected&#39;); if (row)&#123; $(&#39;#dlg&#39;).dialog(&#39;open&#39;).dialog(&#39;setTitle&#39;,&#39;Edit&#39;); $(&#39;#fm&#39;).form(&#39;load&#39;,row); &#x2F;&#x2F;url &#x3D; &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;weibo&#x2F;update?id&#x3D;&#39;+row.id; url &#x3D; &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;weibo&#x2F;update&#39;; &#125;&#125;function saveUser()&#123; var rank &#x3D; fm.rank.value; var title &#x3D; fm.title.value; var view &#x3D; fm.view.value; var row &#x3D; $(&#39;#dg&#39;).datagrid(&#39;getSelected&#39;); var id &#x3D; row.id; var data &#x3D; &#123;id:id,rank:rank,title:title,view:view&#125;; $.ajax(&#123; type: &quot;post&quot;, dataType: &quot;json&quot;, url: url, data: JSON.stringify(data), contentType:&quot;application&#x2F;json&quot;, success: function (data) &#123; $.post(url,data,function(result)&#123; if (result.success)&#123; $(&#39;#dg&#39;).datagrid(&#39;reload&#39;); &#x2F;&#x2F; reload the user data &#125; else &#123; $.messager.show(&#123; &#x2F;&#x2F; show error message title: &#39;Error&#39;, msg: result.msg &#125;); &#125; &#125;,&#39;json&#39;); &#125; &#125;);&#125;function removeUser()&#123; var row &#x3D; $(&#39;#dg&#39;).datagrid(&#39;getSelected&#39;); if (row)&#123; $.messager.confirm(&#39;Confirm&#39;,&#39;Are you sure you want to remove this user?&#39;,function(r)&#123; if (r)&#123; $.post(&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;weibo&#x2F;delete&#39;,&#123;id:row.id&#125;,function(result)&#123; if (result.success)&#123; $(&#39;#dg&#39;).datagrid(&#39;reload&#39;); &#x2F;&#x2F; reload the user data &#125; else &#123; $.messager.show(&#123; &#x2F;&#x2F; show error message title: &#39;Error&#39;, msg: result.msg &#125;); &#125; &#125;,&#39;json&#39;); &#125; &#125;); &#125;&#125; &lt;&#x2F;script&gt; 运用easyui中datagrid控件显示数据 12345678910111213141516171819202122232425262728293031&lt;script&gt; $(&#39;#dg&#39;).datagrid(&#123; columns : [ [ &#x2F;&#x2F;添加列 &#123; field : &#39;id&#39;, &#x2F;&#x2F;绑定数据源ID title : &#39;id&#39;, &#x2F;&#x2F;显示列名称 align : &#39;center&#39;, &#x2F;&#x2F;内容在列居中 width : 100 &#x2F;&#x2F;列的宽度 &#125;, &#123; field : &#39;rank&#39;, title : &#39;rank&#39;, align : &#39;center&#39;, width : 100 &#125;, &#123; field : &#39;title&#39;, title : &#39;title&#39;, align : &#39;center&#39;, width : 100 &#125;, &#123; field : &#39;view&#39;, title : &#39;view&#39;, align : &#39;center&#39;, width : 100 &#125;, ] ], url : &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;weibo&#39;, &#x2F;&#x2F;获取数据地址 &#125;);&lt;&#x2F;script&gt;","categories":[],"tags":[]},{"title":"访问测试路径出现异常","slug":"study1","date":"2020-10-23T11:12:49.000Z","updated":"2020-11-23T11:18:20.201Z","comments":true,"path":"2020/10/23/study1/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/10/23/study1/","excerpt":"","text":"问题 访问测试项目路径localhost:8080 后台抛出异常:This application has no explicit mapping for /error, so you are seeing this as a fallback. 原因及解决方法 Application启动类的位置不对：要将Application类放在最外侧，即包含所有子包 ，spring-boot会自动加载启动类所在包下及其子包下的所有组件。 springboot的配置文件有误：关于application.yml或application.properties文件中视图解析器的配置问题。在pom文件下的spring-boot-starter-paren版本较高时使用以下配置：spring.mvc.view.prefix/spring.mvc.view.suffix，当pom文件下的spring-boot-starter-paren版本较低时使用以下配置：spring.view.prefix/spring.view.suffix。 控制器的url访问路径与注解@RestMapping（”/xxxx”）不匹配。例：12@RequestMapping(value&#x3D;&quot;&#x2F;hello&quot;, method &#x3D; RequestMethod.GET)url &#x3D; http:&#x2F;&#x2F;localhost:8080&#x2F;hello 代码内注解是否正确完整@Service，@RestController等是否添加。 访问测试项目路径localhost:8080 后台抛出异常:nested exception is org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 2 原因及解决方法 返回结果有多个：将接收数据的方法返回数据类型改为list&lt;&gt;即可。 数据源配置出错 原因及解决方法 错误配置1234spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;数据库名称?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;serverTimezone&#x3D;UTCspring.datasource.username&#x3D;用户名spring.datasource.password&#x3D;密码spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver 正确配置1234spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;数据库名称?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;serverTimezone&#x3D;UTCspring.datasource.username&#x3D;用户名spring.datasource.password&#x3D;密码spring.datasource.driver-class-name&#x3D;com.mysql.cj.jdbc.Driver mysql版本不同驱动配置不同com.mysql.jdbc.Driver是mysql5以前的，而mysql6以后就开始使用com.mysql.cj.jdbc.Driver（需要指定时区）。","categories":[],"tags":[]},{"title":"Other","slug":"other","date":"2020-10-20T07:11:04.000Z","updated":"2020-10-20T07:15:54.761Z","comments":true,"path":"2020/10/20/other/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/10/20/other/","excerpt":"otherMysql 索引 定义&emsp;&emsp;索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。(相当于目录，根据页码找内容) 分类 普通索引&emsp;&emsp;普通索引是最基本的索引类型，唯一任务是加快对数据的访问速度，没有任何限制。创建普通索引时，通常使用的关键字是 INDEX 或 KEY。 唯一性索引&emsp;&emsp;唯一性索引是不允许索引列具有相同索引值的索引。如果能确定某个数据列只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字 UNIQUE 把它定义为一个唯一性索引。 主键索引&emsp;&emsp;主键索引是一种唯一性索引，即不允许值重复或者值为空，并且每个表只能有一个主键。主键可以在创建表的时候指定，也可以通过修改表的方式添加，必须指定关键字 PRIMARY KEY。 空间索引&emsp;&emsp;空间索引主要用于地理空间数据类型 GEOMETRY。 全文索引&emsp;&emsp;全文索引只能在 VARCHAR 或 TEXT 类型的列上创建，并且只能在 MyISAM 表中创建。 执行计划&emsp;&emsp;执行计划，就是一条SQL语句，在数据库中实际执行的时候，一步步的分别都做了什么。 事务&emsp;&emsp;事务是逻辑上的一组操作，组成这组操作的各个单元，要不全都成功要不全都失败，这个特性就是事务。 幻读、脏读和不可重复读 幻读&emsp;&emsp;在一次事务里面，多次查询之后，结果集的个数不一致的情况叫做幻读。而多出来或者少的哪一行被叫做幻行。 脏读&emsp;&emsp;脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。 不可重复读&emsp;&emsp;在同一事务中，两次读取同一数据，得到内容不同。 主键&emsp;&emsp;主键是数据表的唯一索引，指的是一个列或多列的组合，其值能唯一地标识表中的每一行，通过它可强制表的实体完整性，主键主要是用与其他表的外键关联，以及本记录的修改与删除。 视图&emsp;&emsp;视图是一种虚拟存在的表，是一个逻辑表，本身并不包含数据，作为一个select语句保存在数据字典中的。","text":"otherMysql 索引 定义&emsp;&emsp;索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。(相当于目录，根据页码找内容) 分类 普通索引&emsp;&emsp;普通索引是最基本的索引类型，唯一任务是加快对数据的访问速度，没有任何限制。创建普通索引时，通常使用的关键字是 INDEX 或 KEY。 唯一性索引&emsp;&emsp;唯一性索引是不允许索引列具有相同索引值的索引。如果能确定某个数据列只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字 UNIQUE 把它定义为一个唯一性索引。 主键索引&emsp;&emsp;主键索引是一种唯一性索引，即不允许值重复或者值为空，并且每个表只能有一个主键。主键可以在创建表的时候指定，也可以通过修改表的方式添加，必须指定关键字 PRIMARY KEY。 空间索引&emsp;&emsp;空间索引主要用于地理空间数据类型 GEOMETRY。 全文索引&emsp;&emsp;全文索引只能在 VARCHAR 或 TEXT 类型的列上创建，并且只能在 MyISAM 表中创建。 执行计划&emsp;&emsp;执行计划，就是一条SQL语句，在数据库中实际执行的时候，一步步的分别都做了什么。 事务&emsp;&emsp;事务是逻辑上的一组操作，组成这组操作的各个单元，要不全都成功要不全都失败，这个特性就是事务。 幻读、脏读和不可重复读 幻读&emsp;&emsp;在一次事务里面，多次查询之后，结果集的个数不一致的情况叫做幻读。而多出来或者少的哪一行被叫做幻行。 脏读&emsp;&emsp;脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。 不可重复读&emsp;&emsp;在同一事务中，两次读取同一数据，得到内容不同。 主键&emsp;&emsp;主键是数据表的唯一索引，指的是一个列或多列的组合，其值能唯一地标识表中的每一行，通过它可强制表的实体完整性，主键主要是用与其他表的外键关联，以及本记录的修改与删除。 视图&emsp;&emsp;视图是一种虚拟存在的表，是一个逻辑表，本身并不包含数据，作为一个select语句保存在数据字典中的。 Java 发展历史 1995年5月23日，Java语言诞生 1996年1月，第一个JDK-JDK1.0诞生 1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术 1996年9月，约8.3万个网页应用了JAVA技术来制作 1997年2月18日，JDK1.1发布 1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录 1997年9月，JavaDeveloperConnection社区成员超过十万 1998年2月，JDK1.1被下载超过2,000,000次 1998年12月8日，JAVA2企业平台J2EE发布 1999年6月，SUN公司发布Java的三个版本：标准版（JavaSE,以前是J2SE）、企业版（JavaEE以前是J2EE）和微型版（JavaME，以前是J2ME） 2000年5月8日，JDK1.3发布 2000年5月29日，JDK1.4发布 2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机 2001年9月24日，J2EE1.3发布 2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升 2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0 2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字”2”：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME 2006年12月，SUN公司发布JRE6.0 2009年04月20日，甲骨文74亿美元收购Sun。取得java的版权。 2010年11月，由于甲骨文对于Java社区的不友善，因此Apache扬言将退出JCP。 2011年7月28日，甲骨文发布java7.0的正式版。 命名规范 包命名全小写，由域名定义，一般采用自己在互联网上的域名(com.jianguo.service)。 类名每个单词首字母大写(TestTime)。 方法名首字母小写后面其他单词首字母大写(public static void openFile(){})。 常量名全部大写常加”_”，并指出完整定义，多个单词组成用下划线分隔(public static final int NUMBER=0)。 参数名与方法命名相同，尽量用一个单词(public void test(String str)中str)。 变量命名 camel标记法：首字母小写，后面单词都以大写字母开头。 pascal标记法：首字母大写，后面单词首字母大写。 匈牙利标记法：在以pascal标记法的变量前附加小写序列说明变量类型(scope_typeVariableName)。 Java bean JavaBean 是一种JAVA语言写成的可重用组件，为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器，JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性。 JavaBean可分为两种：&emsp;&emsp;一种是有用户界面（UI，User Interface）的JavaBean；还有一种是没有用户界面，主要负责处理事务（如数据运算，操纵数据库）的JavaBean。 多态和继承 多态&emsp;&emsp;多态是同一个行为具有多个不同表现形式或形态的能力，是对象多种表现形式的体现(动物有很多种：狗，毛，鱼等)。 继承&emsp;&emsp;继承是面向对象最显著的一个特性,是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力,是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。 Java mvc MVC 模式代表 Model-View-Controller(模型-视图-控制器)模式 Model(模型)：模型代表一个存取数据的对象或 JAVA POJO,它也可以带有逻辑，在数据变化时更新控制器。 View(视图)：视图代表模型包含的数据的可视化。 异常处理 异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。 异常发生的原因有很多，通常包含以下几大类： 用户输入了非法数据。 要打开的文件不存在。 网络通信时连接中断，或者JVM内存溢出。 Exception类的层次&emsp;&emsp;Exception 类是 Throwable 类的子类,有两个主要的子类：IOException 类和 RuntimeException 类。异常处理 Java 注解开发 注解作用&emsp;&emsp;用于告诉编译器javac或工具软件传达一种信息,相当于一个标记，加了注解就等于打上了某种标记，没加就等于没有某种标记，以后，javac编译器，开发工具和其他程序可以用反射来了解你的类及各种元素上有无何种标记，看你有什么标记就去干相应的事,标记可以加在包、类、方法、字段、方法的参数及局部变量上。 基本注解&emsp;&emsp;Deprecated过时的,FunctionalInterface函数式接口：一种特殊类型的接口，这种接口中只定义了唯一的抽象方法的接口，Override 覆盖 ，SafeVarargs 可变参数安全性注解，SuppressWarnings过滤警告注解。 元注解 @Retention标记注解的生命周期，三种取值分别为：RetentionPolicy.SOURCE RetentionPolicy.CLASS RetentionPolicy.RUNNTIME 分别对应：源文件注解，class文件注解，内存中字节码，默认值是在class阶段@Override是在编译阶段覆盖的，因此它的Retention是source @SuppressWarnings也是source Deprecated是runtime 。 @Target 标记给哪个元素添加注解取值分别为ElementType.Annotation_Type ElementType.Constructor ElementType.FIELD等等。","categories":[],"tags":[]},{"title":"Java","slug":"java","date":"2020-10-20T07:10:57.000Z","updated":"2020-10-20T07:18:54.287Z","comments":true,"path":"2020/10/20/java/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/10/20/java/","excerpt":"JavaJava 基础语法 Java大小写敏感，类名首字母大写且每个单词首字母都要大写，方法名首字母小写其他同类名，源文件名必须和类名相同且后缀为.java，所有的Java 程序由public static void main(String[] args)方法开始执行。 标识符：以大小写字母、$、_开始，后面可跟任何字符，关键字不能当标识符，大小写敏感。 修饰符：访问控制修饰符 : default, public , protected, private,非访问控制修饰符 : final, abstract, static，synchronized 和 volatile。 关键字 基本数据类型 Java语言提供了八种基本类型。六种数字类型(四个整数型，两个浮点型)，一种字符类型，还有一种布尔型。 byte(包装类Byte) byte数据类型是8位、有符号的，以二进制补码表示的整数，最小值是-128(-2^7)，最大值是127(2^7-1)。 short(包装类Short) short数据类型是16位、有符号的以二进制补码表示的整数,最小值是-32768(-2^15)，最大值是32767(2^15 - 1)。 int(包装类Integer) int数据类型是32位、有符号的以二进制补码表示的整数，最小值是-2,147,483,648(-2^31)，最大值是2,147,483,647(2^31 - 1)。 long(包装类Long) long数据类型是64位、有符号的以二进制补码表示的整数，最小值是-9,223,372,036,854,775,808(-2^63)，最大值是9,223,372,036,854,775,807(2^63 -1)。 float(包装类Float) float数据类型是单精度、32位、符合IEEE 754标准的浮点数，浮点数不能用来表示精确的值，如货币。 double(包装类Double) double数据类型是双精度、64位、符合IEEE 754标准的浮点数，double类型同样不能表示精确的值，如货币。 boolean(包装类Boolean) boolean数据类型表示一位的信息，只有两个取值：true和false。 char(包装类Character) char类型是一个单一的16位Unicode字符，最小值是’/u0000’(即为0)，最大值是’/uffff’(即为65,535)。 转义符","text":"JavaJava 基础语法 Java大小写敏感，类名首字母大写且每个单词首字母都要大写，方法名首字母小写其他同类名，源文件名必须和类名相同且后缀为.java，所有的Java 程序由public static void main(String[] args)方法开始执行。 标识符：以大小写字母、$、_开始，后面可跟任何字符，关键字不能当标识符，大小写敏感。 修饰符：访问控制修饰符 : default, public , protected, private,非访问控制修饰符 : final, abstract, static，synchronized 和 volatile。 关键字 基本数据类型 Java语言提供了八种基本类型。六种数字类型(四个整数型，两个浮点型)，一种字符类型，还有一种布尔型。 byte(包装类Byte) byte数据类型是8位、有符号的，以二进制补码表示的整数，最小值是-128(-2^7)，最大值是127(2^7-1)。 short(包装类Short) short数据类型是16位、有符号的以二进制补码表示的整数,最小值是-32768(-2^15)，最大值是32767(2^15 - 1)。 int(包装类Integer) int数据类型是32位、有符号的以二进制补码表示的整数，最小值是-2,147,483,648(-2^31)，最大值是2,147,483,647(2^31 - 1)。 long(包装类Long) long数据类型是64位、有符号的以二进制补码表示的整数，最小值是-9,223,372,036,854,775,808(-2^63)，最大值是9,223,372,036,854,775,807(2^63 -1)。 float(包装类Float) float数据类型是单精度、32位、符合IEEE 754标准的浮点数，浮点数不能用来表示精确的值，如货币。 double(包装类Double) double数据类型是双精度、64位、符合IEEE 754标准的浮点数，double类型同样不能表示精确的值，如货币。 boolean(包装类Boolean) boolean数据类型表示一位的信息，只有两个取值：true和false。 char(包装类Character) char类型是一个单一的16位Unicode字符，最小值是’/u0000’(即为0)，最大值是’/uffff’(即为65,535)。 转义符 变量类型 在 Java 语言中，所有的变量在使用前必须声明。Java 语言支持的变量类型有：局部变量 实例变量 类变量。 局部变量 局部变量声明在方法、构造方法或者语句块中。 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。 访问修饰符不能用于局部变量。 局部变量只在声明它的方法、构造方法或者语句块中可见。 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 实例变量 实例变量声明在一个类中，但在方法、构造方法和语句块之外。 当一个对象被实例化之后，每个实例变量的值就跟着确定。 实例变量在对象创建的时候创建，在对象被销毁的时候销毁。 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。 实例变量可以声明在使用前或者使用后。 访问修饰符可以修饰实例变量。 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见。 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定。 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。 类变量 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法、构造方法和语句块之外。 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。 静态变量除了被声明为常量外很少使用。常量是指声明为 public/private，final 和 static 类型的变量。常量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。 静态变量在程序开始时创建，在程序结束时销毁。 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 静态变量可以通过：ClassName.VariableName 的方式访问。 类变量被声明为 public static final 类型时，类变量名称必须使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。 Java 流(Stream)、文件(File)和IO Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标；一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据；Java为I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。 控制台 Java 的控制台输入由 System.in 完成。为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。 读取多字符输入 从 BufferedReader 对象读取一个字符要使用 read() 方法(int read() throws IOException)。 读取字符串 从标准输入读取一个字符串需要使用 BufferedReader 的 readLine() 方法(String readLine() throws IOException)。 流一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。 目录 创建目录 mkdir( ) 方法创建一个文件夹，成功则返回 true，失败则返回 false；mkdirs( ) 方法创建一个文件夹和它的所有父文件夹。 读取目录 一个目录其实就是一个 File 对象，它包含其他文件和文件夹；可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。 面向对象 重写重载 重写(Override) 重写是子类对父类的允许访问的方法的实现过程进行重新编写！返回值和形参都 &emsp;&emsp;不能改变。即外壳不变，核心重写！&emsp;&emsp;参数列表必须完全与被重写方法的相同。&emsp;&emsp;返回类型必须完全与被重写方法的返回类型相同。&emsp;&emsp;子类方法的访问权限必须大于或等于父类方法的访问权限。&emsp;&emsp;父类的成员方法只能被它的子类重写。&emsp;&emsp;声明为 final 的方法不能被重写。&emsp;&emsp;声明为 static 的方法不能被重写，但是能够被再次声明。&emsp;&emsp;子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。&emsp;&emsp;子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。&emsp;&emsp;重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。&emsp;&emsp;构造方法不能被重写。&emsp;&emsp;如果不能继承一个方法，则不能重写这个方法。 重载(Overload) 重载 (overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同，每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。&emsp;&emsp;被重载的方法必须改变参数列表。&emsp;&emsp;被重载的方法可以改变返回类型。&emsp;&emsp;被重载的方法可以改变访问修饰符。&emsp;&emsp;被重载的方法可以声明新的或更广的检查异常。&emsp;&emsp;方法能够在同一个类中或者在一个子类中被重载。&emsp;&emsp;无法以返回值类型作为重载函数的区分标准。 区别&emsp;&emsp;方法的重写 (Overriding) 和重载 (Overloading) 是 java 多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。&emsp;&emsp;方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载 (Overloading)。&emsp;&emsp;方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写 (Overriding)。&emsp;&emsp;方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。 抽象 抽象类 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。 抽象方法 Abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体，抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号，如果一个类包含抽象方法，那么该类必须是抽象类，任何子类必须重写父类的抽象方法，或者声明自身为抽象类。 封装&emsp;&emsp;在面向对象程式设计方法中，封装（英语：Encapsulation）是指，一种将抽象性函式接口的实作细节部份包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。 接口 接口在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。接口与类相似： 一个接口可以有多个方法。 接口文件保存在.java结尾的文件中，文件名使用接口名。 接口的字节码文件保存在.class结尾的文件中。 接口相应的字节码文件必须在与包名称相匹配的目录结构中。区别： 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了static和final变量。 接口不是被类继承了，而是要被类实现。 接口支持多重继承。 声明 [可见度] interface 接口名称 [extends 其他的类名] {} 实现 public class 类名 implement 接口名称[, 其他接口, 其他接口…, …] 继承 一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。也可多重继承 public interface Hockey extends 接口1, 接口2。 集合框架 序列化 Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。整个过程都是Java虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 序列化对象ObjectOutputStream 类用来序列化一个对象，如下的SerializeDemo例子实例化了一个Employee对象，并将该对象序列化到一个文件中。该程序执行后，就创建了一个名为employee.ser文件。12345678910111213141516171819202122import java.io.*;public class SerializeDemo&#123; public static void main(String [] args)&#123; Employee e &#x3D; new Employee(); e.name &#x3D; &quot;Reyan Ali&quot;; e.address &#x3D; &quot;Phokka Kuan, Ambehta Peer&quot;; e.SSN &#x3D; 11122333; e.number &#x3D; 101; try&#123; FileOutputStream fileOut &#x3D; new FileOutputStream(&quot;&#x2F;tmp&#x2F;employee.ser&quot;); ObjectOutputStream out &#x3D; new ObjectOutputStream(fileOut); out.writeObject(e); out.close(); fileOut.close(); System.out.printf(&quot;Serialized data is saved in &#x2F;tmp&#x2F;employee.ser&quot;); &#125;catch(IOException i)&#123; i.printStackTrace(); &#125; &#125;&#125; 反序列化对象12345678910111213141516171819202122232425import java.io.*;public class DeserializeDemo&#123; public static void main(String [] args)&#123; Employee e &#x3D; null; try&#123; FileInputStream fileIn &#x3D; new FileInputStream(&quot;&#x2F;tmp&#x2F;employee.ser&quot;); ObjectInputStream in &#x3D; new ObjectInputStream(fileIn); e &#x3D; (Employee) in.readObject(); in.close(); fileIn.close(); &#125;catch(IOException i)&#123; i.printStackTrace(); return; &#125;catch(ClassNotFoundException c)&#123; System.out.println(&quot;Employee class not found&quot;); c.printStackTrace(); return; &#125; System.out.println(&quot;Deserialized Employee...&quot;); System.out.println(&quot;Name: &quot; + e.name); System.out.println(&quot;Address: &quot; + e.address); System.out.println(&quot;SSN: &quot; + e.SSN); System.out.println(&quot;Number: &quot; + e.number); &#125;&#125; 多线程 多线程编程&emsp;&emsp;Java 给多线程编程提供了内置的支持。一个多线程程序包含两个或多个能并发运行的部分。程序的每一部分都称作一个线程，并且每个线程定义了一个独立的执行路径。一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守候线程都结束运行后才能结束。 线程生命周期 新建（new Thread） 当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。 就绪（runnable） 线程已经被启动，正在等待被分配给 CPU 时间片，也就是说此时线程正在就绪队列中排队等候得到 CPU 资源。 运行（running） 线程获得 CPU 资源正在执行任务（ run() 方法），此时除非此线程自动放弃 CPU 资源或者有优先级更高的线程进入，线程将一直运行到结束。 堵塞（blocked） 由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。正在睡眠：用 sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。正在等待：调用 wait() 方法。（调用 motify() 方法回到就绪状态）。被另一个线程所阻塞：调用 suspend() 方法。（调用 resume() 方法恢复）。 死亡（dead）当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。自然终止：正常运行 run() 方法后终止。异常终止：调用 stop() 方法让一个线程终止运行。 优先级&emsp;&emsp;每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。Java 优先级在 MIN_PRIORITY（1）和 MAX_PRIORITY（10）之间的范围内。默认情况下，每一个线程都会分配一个优先级NORM_PRIORITY（5）。 Applet基础 applet是一种Java程序。它一般运行在支持Java的Web浏览器内。因为它有完整的Java API支持,所以applet是一个全功能的Java应用程序。Java应用程序和applet程序之间重要的不同： Java中applet类继承了 java.applet.Applet类。 Applet类没有定义main()，所以一个 Applet程序不会调用main()方法。 Applets被设计为嵌入在一个HTML页面。 当用户浏览包含Applet的HTML页面，Applet的代码就被下载到用户的机器上。 要查看一个applet需要JVM。 JVM可以是Web浏览器的一个插件，或一个独立的运行时环境。 用户机器上的JVM创建一个applet类的实例，并调用Applet生命周期过程中的各种方法。 Applets有Web浏览器强制执行的严格的安全规则，applet的安全机制被称为沙箱安全。 applet需要的其他类可以用Java归档（JAR）文件的形式下载下来。 生命周期Applet类中的四个方法提供了一个框架： init: 该方法的目的是为你的applet提供所需的任何初始化。在Applet标记内的param标签被处理后调用该方法。 start: 浏览器调用init方法后，该方法被自动调用。每当用户从其他页面返回到包含Applet的页面时，则调用该方法。 stop:当用户从包含applet的页面移除的时候，该方法自动被调用。因此，可以在相同的applet中反复调用该方法。 destroy: 此方法仅当浏览器正常关闭时调用。因为applets只有在HTML网页上有效，所以你不应该在用户离开包含Applet的页面后遗漏任何资源。 paint: 该方法在start()方法之后立即被调用，或者在applet需要重绘在浏览器的时候调用。paint()方法实际上继承于java.awt。 Applet 类&emsp;&emsp;每一个applet都是java.applet.Applet 类的子类，基础的Applet类提供了供衍生类调用的方法,以此来得到浏览器上下文的信息和服务。这些方法做了如下事情：&emsp;&emsp;得到applet的参数，得到包含applet的HTML文件的网络位置，得到applet类目录的网络位置，打印浏览器的状态信息，获取一张图片，获取一个音频片段，播放一个音频片段，调整此 applet 的大小。&emsp;&emsp;Applet类还提供了一个接口，该接口供Viewer或浏览器来获取applet的信息，并且来控制applet的执行。Viewer可能是：&emsp;&emsp;请求applet作者、版本和版权的信息，请求applet识别的参数的描述，初始化applet，销毁applet，开始执行applet，结束执行applet。 设计模式 分类创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。结构型模式：把类或对象结合在一起形成一个更大的结构。行为型模式：类和对象如何交互，及划分责任和算法。 创建型模式单例模式：某个类只能有一个实例，提供一个全局的访问点。简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。原型模式：通过复制现有的实例来创建新的实例。 结构型模式适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。装饰模式：动态的给对象添加新的功能。代理模式：为其他对象提供一个代理以便控制这个对象的访问。亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。 行为型模式模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。状态模式：允许一个对象在其对象内部状态改变时改变它的行为。观察者模式：对象间的一对多的依赖关系。备忘录模式：在不破坏封装的前提下，保持对象的内部状态。中介者模式：用一个中介对象来封装一系列的对象交互。命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。23种模式 Java项目 微博项目12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Search &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; mysql连接地址，用户名，密码，插入语句 &#x2F;&#x2F; 微博热搜地址 String myUrl &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;weibo?usaSSl&#x3D;false&amp;serverTimezone&#x3D;UTC&quot;; String name &#x3D; &quot;root&quot;; String pwd &#x3D; &quot;156176pwd&quot;; String sql &#x3D; &quot;INSERT INTO search(s_rank,s_title,s_view) VALUES(?,?,?)&quot;; String url &#x3D; &quot;https:&#x2F;&#x2F;s.weibo.com&#x2F;top&#x2F;summary&#x2F;summary?cate&#x3D;realtimehot&quot;; try &#123; &#x2F;&#x2F; 连接数据库 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); Connection connection &#x3D; DriverManager.getConnection(myUrl, name, pwd); &#x2F;&#x2F; 得到微博热搜数据 Document document &#x3D; Jsoup.connect(url).get(); &#x2F;&#x2F; 爬取指定微博热搜数据并储存 Elements r &#x3D; document.select(&quot;td[class&#x3D;&#39;td-01 ranktop&#39;]&quot;); String[] rank &#x3D; r.eachText().toArray(new String[0]); Elements t &#x3D; document.select(&quot;td[class&#x3D;&#39;td-02&#39;] a&quot;); String[] title &#x3D; t.eachText().toArray(new String[0]); Elements v &#x3D; document.select(&quot;span&quot;); String[] view &#x3D; v.eachText().toArray(new String[0]); PreparedStatement statement &#x3D; connection.prepareStatement(sql); statement.setString(1, &quot;top&quot;); statement.setString(2, title[0]); statement.setString(3, &quot;&quot;); statement.executeUpdate(); &#x2F;&#x2F; 插入mysql操作 for (int i &#x3D; 0; i &lt; rank.length; i++) &#123; statement.setString(1, rank[i]); statement.setString(2, title[i + 1]); statement.setString(3, view[i]); statement.executeUpdate(); &#125; &#x2F;&#x2F; 插入mysql操作 connection.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; IDEA使用maven打包javapom配置1234567891011121314151617181920212223242526272829303132&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;3.8.1&lt;&#x2F;version&gt; &lt;&#x2F;plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;&#x2F;artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;com.test.app&lt;&#x2F;mainClass&gt; &lt;&#x2F;manifest&gt; &lt;&#x2F;archive&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;&#x2F;descriptorRef&gt; &lt;&#x2F;descriptorRefs&gt; &lt;&#x2F;configuration&gt; &lt;!--下面是为了使用 mvn package命令，如果不加则使用mvn assembly--&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assemble&lt;&#x2F;id&gt; &lt;phase&gt;package&lt;&#x2F;phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;&#x2F;goal&gt; &lt;&#x2F;goals&gt; &lt;&#x2F;execution&gt; &lt;&#x2F;executions&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt;&lt;&#x2F;build&gt;","categories":[],"tags":[]},{"title":"Mysql","slug":"mysql","date":"2020-10-20T07:10:31.000Z","updated":"2020-10-20T07:20:18.589Z","comments":true,"path":"2020/10/20/mysql/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/10/20/mysql/","excerpt":"MysqlMysql Mysql 连接&emsp;&emsp;mysql -u root -p 登录mysql 其中root表示用户，exit退出mysql 基本类型 MySQL 支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。 数值类型 日期/时间类型 字符串类型","text":"MysqlMysql Mysql 连接&emsp;&emsp;mysql -u root -p 登录mysql 其中root表示用户，exit退出mysql 基本类型 MySQL 支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。 数值类型 日期/时间类型 字符串类型 数据库操作 创建mysql命令create database 数据库名称，DOS命令mysqladmin -u root -p create 数据库名称 登录mysql并创建数据库。 删除mysql命令drop database 想要删除的数据库名称，DOS命令mysqladmin -u root -p drop 想要删除的数据库名称 登录mysql并删除数据库(需确认)。 选择mysql命令use 想要选择的数据库名称，DOS命令需先登录mysql再use 想要选择的数据库名称。 show databases; 可查看以拥有数据库。 数据表操作 创建123456create table 表名称( id int not null auto_increment, name1 varchar(100) not null, name2 varchar(40) not null, primary key (id)) AUTO_INCREMENT定义列为自增的属性,每次加1。 PRIMARY KEY关键字用于定义列为主键。 不想字段为 NULL 可以设置字段的属性为 NOT NULL，输入null会报错。 删除 删除表：drop table 想要删除的表名。 删除内容：delete from 表名 [where 条件]，无where则删除全部内容，truncate 表名 删除全部数据。 插入数据insert into 表名(字段名) values(要插入的数据)，其中字段名可以是多个，用逗号隔开，数据要对应字段数量。 查询数据select 查询字段名 from 表名 [where 条件]；无where得到表中所有指定字段数据，查询表中所有数据字段名用”*”表示。 修改数据update 表名 set 字段名=新数据 [where 条件]；无where修改表中所有指定字段的值位新数据，字段名可为多个用逗号隔开。 正则表达式 alter命令 删除、添加修改字段 ALTER TABLE 表名 DROP 字段名; 删除字段。 ALTER TABLE 表名 ADD 字段名 INT; 添加字段。 ALTER TABLE 表名 DROP 字段名; ALTER TABLE 表名 ADD 字段名 INT FIRST; first表示添加到首列，也可用数值代替，数字不能大于字段数量。 修改字段及名称 ALTER TABLE 表名 MODIFY 要修改的字段名 类型; 修改字类型。 ALTER TABLE 表名 CHANGE 要修改的字段名 修改后的字段名 类型; 修改字段名及类型，前后两个字段名相同只修改类型。 ALTER TABLE 表名 MODIFY 字段名 类型 NOT NULL DEFAULT 默认值; 修改默认值或是否不能为null。 修改表名ALTER TABLE 表名 RENAME TO 新表名;","categories":[],"tags":[]},{"title":"Python","slug":"python","date":"2020-10-20T07:10:13.000Z","updated":"2020-10-20T07:15:45.127Z","comments":true,"path":"2020/10/20/python/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/10/20/python/","excerpt":"Python3Python3 基本数据类型 Numbers(数字)Python 3支持int、float、bool、complex(复数)。 Python可以同时为多个变量赋值 一个变量可以通过赋值指向不同类型的对象。 数值的除法（/）总是返回一个浮点数，要获取整数使用//操作符。 在混合计算时，Pyhton会把整型转换成为浮点数。 String(字符)Python中的字符串str用单引号(‘ ‘)或双引号(“ “)括起来。 反斜杠可以用来转义，使用r可以让反斜杠不发生转义(print(‘C:/some/name’),print(r’C:/some/name’))。 字符串可以用+运算符连接在一起，用*运算符重复(print(‘str’+’ing’,’x’*4))。 Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。 Python中的字符串不能改变。 List(列表)List(列表)是 Python 中使用最频繁的数据类型。 List写在方括号之间，元素用逗号隔开。 和字符串一样，list可以被索引和切片。 List可以使用+操作符进行拼接。 List中的元素是可以改变的。 Tuple(元组)元组(tuple)与列表类似，不同之处在于元组的元素不能修改。元组写在小括号里，元素之间用逗号隔开。 与字符串一样，元组的元素不能修改。 元组也可以被索引和切片，方法一样。 注意构造包含0或1个元素的元组的特殊语法规则。 元组也可以使用+操作符进行拼接。 Sets(集合)集合(set)是一个无序不重复元素的集,基本功能是进行成员关系测试和消除重复元素,可以使用大括号 或者 set()函数创建set集合。 Dictionaries(字典)字典（dictionary）是Python中另一个非常有用的内置数据类型,是一种映射类型(mapping type)，它是一个无序的键 : 值对集合。 字典是一种映射类型，它的元素是键值对。 字典的关键字必须为不可变类型，且不能重复。 创建空字典使用{}。","text":"Python3Python3 基本数据类型 Numbers(数字)Python 3支持int、float、bool、complex(复数)。 Python可以同时为多个变量赋值 一个变量可以通过赋值指向不同类型的对象。 数值的除法（/）总是返回一个浮点数，要获取整数使用//操作符。 在混合计算时，Pyhton会把整型转换成为浮点数。 String(字符)Python中的字符串str用单引号(‘ ‘)或双引号(“ “)括起来。 反斜杠可以用来转义，使用r可以让反斜杠不发生转义(print(‘C:/some/name’),print(r’C:/some/name’))。 字符串可以用+运算符连接在一起，用*运算符重复(print(‘str’+’ing’,’x’*4))。 Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。 Python中的字符串不能改变。 List(列表)List(列表)是 Python 中使用最频繁的数据类型。 List写在方括号之间，元素用逗号隔开。 和字符串一样，list可以被索引和切片。 List可以使用+操作符进行拼接。 List中的元素是可以改变的。 Tuple(元组)元组(tuple)与列表类似，不同之处在于元组的元素不能修改。元组写在小括号里，元素之间用逗号隔开。 与字符串一样，元组的元素不能修改。 元组也可以被索引和切片，方法一样。 注意构造包含0或1个元素的元组的特殊语法规则。 元组也可以使用+操作符进行拼接。 Sets(集合)集合(set)是一个无序不重复元素的集,基本功能是进行成员关系测试和消除重复元素,可以使用大括号 或者 set()函数创建set集合。 Dictionaries(字典)字典（dictionary）是Python中另一个非常有用的内置数据类型,是一种映射类型(mapping type)，它是一个无序的键 : 值对集合。 字典是一种映射类型，它的元素是键值对。 字典的关键字必须为不可变类型，且不能重复。 创建空字典使用{}。 运算符 算术运算符 比较符 赋值符 位运算符 逻辑运算符 成员运算符 身份运算符 优先级 Python3项目 微博热搜123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!&#x2F;usr&#x2F;bin&#x2F;python3#encoding&#x3D;utf-8###导入模块import requestsfrom lxml import etreeimport pymysqldef weibo(): #配置数据库 config &#x3D; &#123; &#39;host&#39;:&#39;127.0.0.1&#39;, &#39;port&#39;:3306, &#39;user&#39;:&#39;root&#39;, &#39;password&#39;:&#39;q1561762345&#39;, &#39;db&#39;:&#39;weibo&#39;, &#39;charset&#39;:&#39;utf8&#39;, &#125; #链接数据库 conn&#x3D;pymysql.connect(**config) cursor&#x3D;conn.cursor() &#39;&#39;&#39; 微博热搜榜 实时抓取微博的排行榜!需要设置请求头headers! &#39;&#39;&#39; headers &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;63.0.3239.132 Safari&#x2F;537.36 QIHU 360SE&#39; &#125; url &#x3D; &#39;https:&#x2F;&#x2F;s.weibo.com&#x2F;top&#x2F;summary&#x2F;summary?cate&#x3D;realtimehot&#39; # 获取html页面 html &#x3D; etree.HTML(requests.get(url,headers&#x3D;headers).text) print(html) # 查找指定元素 所有的 rank &#x3D; html.xpath(&#39;&#x2F;&#x2F;td[@class&#x3D;&quot;td-01 ranktop&quot;]&#x2F;text()&#39;) txt &#x3D; html.xpath(&#39;&#x2F;&#x2F;td[@class&#x3D;&quot;td-02&quot;]&#x2F;a&#x2F;text()&#39;) view &#x3D; html.xpath(&#39;&#x2F;&#x2F;td[@class&#x3D;&quot;td-02&quot;]&#x2F;span&#x2F;text()&#39;) top &#x3D; txt[0] txt &#x3D; txt[1:] print(&#39;top&#39; + &#39;&#x2F;t&#39; + top + &#39;&#x2F;t&#39; + str(view[0])) sql&#x3D;&#39;insert into resou (r_rank,r_text,r_view) values (%s,%s,%s)&#39; cursor.execute(sql,(&#39;top&#39;,top,view[0])) conn.commit() for x in range(0,len(view)): print(str(rank[x]) + &#39;&#x2F;t&#39; + str(txt[x]) + &#39;&#x2F;t&#39; + str(view[x])) sql&#x3D;&#39;insert into resou (r_rank,r_text,r_view) values (%s,%s,%s)&#39; cursor.execute(sql,(rank[x],txt[x],view[x])) conn.commit() cursor.close() conn.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: weibo() 百度文字识别1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!&#x2F;usr&#x2F;bin&#x2F;python3# -*- coding: UTF-8 -*-from aip import AipOcrimport pymysql#配置数据库config &#x3D; &#123; &#39;host&#39;:&#39;127.0.0.1&#39;, &#39;port&#39;:3306, &#39;user&#39;:&#39;root&#39;, &#39;password&#39;:&#39;q1561762345&#39;, &#39;db&#39;:&#39;baidu&#39;, &#39;charset&#39;:&#39;utf8&#39;, &#125;#链接数据库conn&#x3D;pymysql.connect(**config)cursor&#x3D;conn.cursor()&#39;&#39;&#39; APPID AK SK &#39;&#39;&#39;APP_ID &#x3D; &#39;22240664&#39;API_KEY &#x3D; &#39;uhO3u1hRCRHefQqMG90PVSyw&#39;SECRET_KEY &#x3D; &#39;wG3QXaqGfd6TiwVSN0vxCyi5muwI0EGi&#39;# 初始化AipFace对象client &#x3D; AipOcr(APP_ID,API_KEY,SECRET_KEY)def get_file_content(filePath): with open(filePath,&#39;rb&#39;) as fp: return fp.read()# 读取图片# 定义参数变量options &#x3D; &#123; &#39;detect_direction&#39;: &#39;true&#39;, &#39;language_type&#39;: &#39;CHN_ENG&#39;,&#125;# 调用通用文字识别接口def addImage(image): def addOptions(options): return client.basicGeneral(image,options) return addOptionsimage &#x3D; get_file_content(&#39;图片地址&#39;)addOption &#x3D; addImage(image)result &#x3D; addOption(options)result &#x3D; result[&#39;words_result&#39;]text &#x3D; &#39;&#39;name &#x3D; &#39;&#39;n &#x3D; 0for i in result: value, &#x3D; i.values() if n &#x3D;&#x3D; 0: name &#x3D; value n &#x3D; n + 1 else: text &#x3D; text + valuesql&#x3D;&#39;insert into kapian (k_name,k_text) values (%s,%s)&#39;cursor.execute(sql,(name,text))conn.commit()cursor.close()conn.close()","categories":[],"tags":[]},{"title":"Shell","slug":"shell","date":"2020-10-20T07:09:40.000Z","updated":"2020-10-20T07:12:02.849Z","comments":true,"path":"2020/10/20/shell/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/10/20/shell/","excerpt":"","text":"Shell shell命令 编辑文件 vi 文件名 复制文件 cp a文件 b文件 将a文件复制一份，b就是复制文件(副本)。 复制文件目录 cp a目录 b目录 -r 将a目录(包含里面的全部文件)内容 复制到b目录下，-r 递归复制。 新建文件 touch 文件名 文件不存在就新建，存在就更新新建的最新修改时间。 移动文件 mv a文件 b目录 将a文件移动到b目录下。 重命名文件 mv a文件 b文件 将a文件命名为b文件。 删除文件 rm a文件 删除文件目录 rm a目录 -r 显示文本内容 cat 文件名 显示字符串 echo “hello” echo hello &gt;&gt; 文件名(向文件中写入hello，如没有文件则创建文件并写入)。 查找文件 find 目录 -name “*.sh” 找出目录下的所有.sh文件 查找字符串 grep “abc”目录 目录中找字符串 “abc”。 列出文件信息 ls 列出当前目录文件信息。 创建目录 mkdir 目录名 显示当前路径 pwd 定时执行 crontab：* * * * * 执行语句每个”*”对应：分，时，日，月，星期。 shell项目1234567891011121314151617181920212223242526272829 while (( 0 &#x3D;&#x3D; 0 ))dodir_name&#x3D;$(date &#39;+%M&#39;) python3 &lt;&lt;EOFimport sysfrom time import sleepsleep(10)EOF &#x2F;&#x2F;暂停10秒# 调用makeF函数runmake&#x3D;$(makeF $dir_name)echo $runmake# 调用timeF函数runtime&#x3D;$(timeF $dir_name)echo $runtimedonefunction makeF()&#123; [ -d &#x2F;mnt&#x2F;f&#x2F;WorkSpace&#x2F;$1 ] ||&#123; mkdir &#x2F;mnt&#x2F;f&#x2F;WorkSpace&#x2F;$1 &#125; # 查询有无文件夹，无则创建，否则不创建 [ -d &#x2F;mnt&#x2F;f&#x2F;WorkSpace&#x2F;$1&#x2F;$1 ] ||&#123; touch &#x2F;mnt&#x2F;f&#x2F;WorkSpace&#x2F;$1&#x2F;$1 &#125; # 查询有无文件，无则创建，否则不创建&#125;function timeF()&#123; echo $(date +%s) &gt;&gt; &#x2F;mnt&#x2F;f&#x2F;WorkSpace&#x2F;$1&#x2F;$1 # 向文件中写如当前时间戳&#125;","categories":[],"tags":[]},{"title":"学习总结","slug":"hello-world","date":"2020-10-16T07:19:05.525Z","updated":"2020-10-16T11:31:53.151Z","comments":true,"path":"2020/10/16/hello-world/","link":"","permalink":"https://fjianguo.github.io/jianguo.github.io/2020/10/16/hello-world/","excerpt":"Shell shell命令 编辑文件 vi 文件名 复制文件 cp a文件 b文件 将a文件复制一份，b就是复制文件(副本)。 复制文件目录 cp a目录 b目录 -r 将a目录(包含里面的全部文件)内容 复制到b目录下，-r 递归复制。 新建文件 touch 文件名 文件不存在就新建，存在就更新新建的最新修改时间。 移动文件 mv a文件 b目录 将a文件移动到b目录下。 重命名文件 mv a文件 b文件 将a文件命名为b文件。 删除文件 rm a文件 删除文件目录 rm a目录 -r 显示文本内容 cat 文件名 显示字符串 echo “hello” echo hello &gt;&gt; 文件名(向文件中写入hello，如没有文件则创建文件并写入)。 查找文件 find 目录 -name “*.sh” 找出目录下的所有.sh文件 查找字符串 grep “abc”目录 目录中找字符串 “abc”。 列出文件信息 ls 列出当前目录文件信息。 创建目录 mkdir 目录名 显示当前路径 pwd 定时执行 crontab：* * * * * 执行语句每个”*”对应：分，时，日，月，星期。 shell项目1234567891011121314151617181920212223242526272829 while (( 0 &#x3D;&#x3D; 0 ))dodir_name&#x3D;$(date &#39;+%M&#39;) python3 &lt;&lt;EOFimport sysfrom time import sleepsleep(10)EOF &#x2F;&#x2F;暂停10秒# 调用makeF函数runmake&#x3D;$(makeF $dir_name)echo $runmake# 调用timeF函数runtime&#x3D;$(timeF $dir_name)echo $runtimedonefunction makeF()&#123; [ -d &#x2F;mnt&#x2F;f&#x2F;WorkSpace&#x2F;$1 ] ||&#123; mkdir &#x2F;mnt&#x2F;f&#x2F;WorkSpace&#x2F;$1 &#125; # 查询有无文件夹，无则创建，否则不创建 [ -d &#x2F;mnt&#x2F;f&#x2F;WorkSpace&#x2F;$1&#x2F;$1 ] ||&#123; touch &#x2F;mnt&#x2F;f&#x2F;WorkSpace&#x2F;$1&#x2F;$1 &#125; # 查询有无文件，无则创建，否则不创建&#125;function timeF()&#123; echo $(date +%s) &gt;&gt; &#x2F;mnt&#x2F;f&#x2F;WorkSpace&#x2F;$1&#x2F;$1 # 向文件中写如当前时间戳&#125;","text":"Shell shell命令 编辑文件 vi 文件名 复制文件 cp a文件 b文件 将a文件复制一份，b就是复制文件(副本)。 复制文件目录 cp a目录 b目录 -r 将a目录(包含里面的全部文件)内容 复制到b目录下，-r 递归复制。 新建文件 touch 文件名 文件不存在就新建，存在就更新新建的最新修改时间。 移动文件 mv a文件 b目录 将a文件移动到b目录下。 重命名文件 mv a文件 b文件 将a文件命名为b文件。 删除文件 rm a文件 删除文件目录 rm a目录 -r 显示文本内容 cat 文件名 显示字符串 echo “hello” echo hello &gt;&gt; 文件名(向文件中写入hello，如没有文件则创建文件并写入)。 查找文件 find 目录 -name “*.sh” 找出目录下的所有.sh文件 查找字符串 grep “abc”目录 目录中找字符串 “abc”。 列出文件信息 ls 列出当前目录文件信息。 创建目录 mkdir 目录名 显示当前路径 pwd 定时执行 crontab：* * * * * 执行语句每个”*”对应：分，时，日，月，星期。 shell项目1234567891011121314151617181920212223242526272829 while (( 0 &#x3D;&#x3D; 0 ))dodir_name&#x3D;$(date &#39;+%M&#39;) python3 &lt;&lt;EOFimport sysfrom time import sleepsleep(10)EOF &#x2F;&#x2F;暂停10秒# 调用makeF函数runmake&#x3D;$(makeF $dir_name)echo $runmake# 调用timeF函数runtime&#x3D;$(timeF $dir_name)echo $runtimedonefunction makeF()&#123; [ -d &#x2F;mnt&#x2F;f&#x2F;WorkSpace&#x2F;$1 ] ||&#123; mkdir &#x2F;mnt&#x2F;f&#x2F;WorkSpace&#x2F;$1 &#125; # 查询有无文件夹，无则创建，否则不创建 [ -d &#x2F;mnt&#x2F;f&#x2F;WorkSpace&#x2F;$1&#x2F;$1 ] ||&#123; touch &#x2F;mnt&#x2F;f&#x2F;WorkSpace&#x2F;$1&#x2F;$1 &#125; # 查询有无文件，无则创建，否则不创建&#125;function timeF()&#123; echo $(date +%s) &gt;&gt; &#x2F;mnt&#x2F;f&#x2F;WorkSpace&#x2F;$1&#x2F;$1 # 向文件中写如当前时间戳&#125; Python3Python3 基本数据类型 Numbers(数字)Python 3支持int、float、bool、complex(复数)。 Python可以同时为多个变量赋值 一个变量可以通过赋值指向不同类型的对象。 数值的除法（/）总是返回一个浮点数，要获取整数使用//操作符。 在混合计算时，Pyhton会把整型转换成为浮点数。 String(字符)Python中的字符串str用单引号(‘ ‘)或双引号(“ “)括起来。 反斜杠可以用来转义，使用r可以让反斜杠不发生转义(print(‘C:/some/name’),print(r’C:/some/name’))。 字符串可以用+运算符连接在一起，用*运算符重复(print(‘str’+’ing’,’x’*4))。 Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。 Python中的字符串不能改变。 List(列表)List(列表)是 Python 中使用最频繁的数据类型。 List写在方括号之间，元素用逗号隔开。 和字符串一样，list可以被索引和切片。 List可以使用+操作符进行拼接。 List中的元素是可以改变的。 Tuple(元组)元组(tuple)与列表类似，不同之处在于元组的元素不能修改。元组写在小括号里，元素之间用逗号隔开。 与字符串一样，元组的元素不能修改。 元组也可以被索引和切片，方法一样。 注意构造包含0或1个元素的元组的特殊语法规则。 元组也可以使用+操作符进行拼接。 Sets(集合)集合(set)是一个无序不重复元素的集,基本功能是进行成员关系测试和消除重复元素,可以使用大括号 或者 set()函数创建set集合。 Dictionaries(字典)字典（dictionary）是Python中另一个非常有用的内置数据类型,是一种映射类型(mapping type)，它是一个无序的键 : 值对集合。 字典是一种映射类型，它的元素是键值对。 字典的关键字必须为不可变类型，且不能重复。 创建空字典使用{}。 运算符 算术运算符 比较符 赋值符 位运算符 逻辑运算符 成员运算符 身份运算符 优先级 Python3项目 微博热搜123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!&#x2F;usr&#x2F;bin&#x2F;python3#encoding&#x3D;utf-8###导入模块import requestsfrom lxml import etreeimport pymysqldef weibo(): #配置数据库 config &#x3D; &#123; &#39;host&#39;:&#39;127.0.0.1&#39;, &#39;port&#39;:3306, &#39;user&#39;:&#39;root&#39;, &#39;password&#39;:&#39;q1561762345&#39;, &#39;db&#39;:&#39;weibo&#39;, &#39;charset&#39;:&#39;utf8&#39;, &#125; #链接数据库 conn&#x3D;pymysql.connect(**config) cursor&#x3D;conn.cursor() &#39;&#39;&#39; 微博热搜榜 实时抓取微博的排行榜!需要设置请求头headers! &#39;&#39;&#39; headers &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;63.0.3239.132 Safari&#x2F;537.36 QIHU 360SE&#39; &#125; url &#x3D; &#39;https:&#x2F;&#x2F;s.weibo.com&#x2F;top&#x2F;summary&#x2F;summary?cate&#x3D;realtimehot&#39; # 获取html页面 html &#x3D; etree.HTML(requests.get(url,headers&#x3D;headers).text) print(html) # 查找指定元素 所有的 rank &#x3D; html.xpath(&#39;&#x2F;&#x2F;td[@class&#x3D;&quot;td-01 ranktop&quot;]&#x2F;text()&#39;) txt &#x3D; html.xpath(&#39;&#x2F;&#x2F;td[@class&#x3D;&quot;td-02&quot;]&#x2F;a&#x2F;text()&#39;) view &#x3D; html.xpath(&#39;&#x2F;&#x2F;td[@class&#x3D;&quot;td-02&quot;]&#x2F;span&#x2F;text()&#39;) top &#x3D; txt[0] txt &#x3D; txt[1:] print(&#39;top&#39; + &#39;&#x2F;t&#39; + top + &#39;&#x2F;t&#39; + str(view[0])) sql&#x3D;&#39;insert into resou (r_rank,r_text,r_view) values (%s,%s,%s)&#39; cursor.execute(sql,(&#39;top&#39;,top,view[0])) conn.commit() for x in range(0,len(view)): print(str(rank[x]) + &#39;&#x2F;t&#39; + str(txt[x]) + &#39;&#x2F;t&#39; + str(view[x])) sql&#x3D;&#39;insert into resou (r_rank,r_text,r_view) values (%s,%s,%s)&#39; cursor.execute(sql,(rank[x],txt[x],view[x])) conn.commit() cursor.close() conn.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: weibo() 百度文字识别1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!&#x2F;usr&#x2F;bin&#x2F;python3# -*- coding: UTF-8 -*-from aip import AipOcrimport pymysql#配置数据库config &#x3D; &#123; &#39;host&#39;:&#39;127.0.0.1&#39;, &#39;port&#39;:3306, &#39;user&#39;:&#39;root&#39;, &#39;password&#39;:&#39;q1561762345&#39;, &#39;db&#39;:&#39;baidu&#39;, &#39;charset&#39;:&#39;utf8&#39;, &#125;#链接数据库conn&#x3D;pymysql.connect(**config)cursor&#x3D;conn.cursor()&#39;&#39;&#39; APPID AK SK &#39;&#39;&#39;APP_ID &#x3D; &#39;22240664&#39;API_KEY &#x3D; &#39;uhO3u1hRCRHefQqMG90PVSyw&#39;SECRET_KEY &#x3D; &#39;wG3QXaqGfd6TiwVSN0vxCyi5muwI0EGi&#39;# 初始化AipFace对象client &#x3D; AipOcr(APP_ID,API_KEY,SECRET_KEY)def get_file_content(filePath): with open(filePath,&#39;rb&#39;) as fp: return fp.read()# 读取图片# 定义参数变量options &#x3D; &#123; &#39;detect_direction&#39;: &#39;true&#39;, &#39;language_type&#39;: &#39;CHN_ENG&#39;,&#125;# 调用通用文字识别接口def addImage(image): def addOptions(options): return client.basicGeneral(image,options) return addOptionsimage &#x3D; get_file_content(&#39;图片地址&#39;)addOption &#x3D; addImage(image)result &#x3D; addOption(options)result &#x3D; result[&#39;words_result&#39;]text &#x3D; &#39;&#39;name &#x3D; &#39;&#39;n &#x3D; 0for i in result: value, &#x3D; i.values() if n &#x3D;&#x3D; 0: name &#x3D; value n &#x3D; n + 1 else: text &#x3D; text + valuesql&#x3D;&#39;insert into kapian (k_name,k_text) values (%s,%s)&#39;cursor.execute(sql,(name,text))conn.commit()cursor.close()conn.close() MysqlMysql Mysql 连接&emsp;&emsp;mysql -u root -p 登录mysql 其中root表示用户，exit退出mysql 基本类型 MySQL 支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。 数值类型 日期/时间类型 字符串类型 数据库操作 创建mysql命令create database 数据库名称，DOS命令mysqladmin -u root -p create 数据库名称 登录mysql并创建数据库。 删除mysql命令drop database 想要删除的数据库名称，DOS命令mysqladmin -u root -p drop 想要删除的数据库名称 登录mysql并删除数据库(需确认)。 选择mysql命令use 想要选择的数据库名称，DOS命令需先登录mysql再use 想要选择的数据库名称。 show databases; 可查看以拥有数据库。 数据表操作 创建123456create table 表名称( id int not null auto_increment, name1 varchar(100) not null, name2 varchar(40) not null, primary key (id)) AUTO_INCREMENT定义列为自增的属性,每次加1。 PRIMARY KEY关键字用于定义列为主键。 不想字段为 NULL 可以设置字段的属性为 NOT NULL，输入null会报错。 删除 删除表：drop table 想要删除的表名。 删除内容：delete from 表名 [where 条件]，无where则删除全部内容，truncate 表名 删除全部数据。 插入数据insert into 表名(字段名) values(要插入的数据)，其中字段名可以是多个，用逗号隔开，数据要对应字段数量。 查询数据select 查询字段名 from 表名 [where 条件]；无where得到表中所有指定字段数据，查询表中所有数据字段名用”*”表示。 修改数据update 表名 set 字段名=新数据 [where 条件]；无where修改表中所有指定字段的值位新数据，字段名可为多个用逗号隔开。 正则表达式 alter命令 删除、添加修改字段 ALTER TABLE 表名 DROP 字段名; 删除字段。 ALTER TABLE 表名 ADD 字段名 INT; 添加字段。 ALTER TABLE 表名 DROP 字段名; ALTER TABLE 表名 ADD 字段名 INT FIRST; first表示添加到首列，也可用数值代替，数字不能大于字段数量。 修改字段及名称 ALTER TABLE 表名 MODIFY 要修改的字段名 类型; 修改字类型。 ALTER TABLE 表名 CHANGE 要修改的字段名 修改后的字段名 类型; 修改字段名及类型，前后两个字段名相同只修改类型。 ALTER TABLE 表名 MODIFY 字段名 类型 NOT NULL DEFAULT 默认值; 修改默认值或是否不能为null。 修改表名ALTER TABLE 表名 RENAME TO 新表名;JavaJava 基础语法 Java大小写敏感，类名首字母大写且每个单词首字母都要大写，方法名首字母小写其他同类名，源文件名必须和类名相同且后缀为.java，所有的Java 程序由public static void main(String[] args)方法开始执行。 标识符：以大小写字母、$、_开始，后面可跟任何字符，关键字不能当标识符，大小写敏感。 修饰符：访问控制修饰符 : default, public , protected, private,非访问控制修饰符 : final, abstract, static，synchronized 和 volatile。 关键字 基本数据类型 Java语言提供了八种基本类型。六种数字类型(四个整数型，两个浮点型)，一种字符类型，还有一种布尔型。 byte(包装类Byte) byte数据类型是8位、有符号的，以二进制补码表示的整数，最小值是-128(-2^7)，最大值是127(2^7-1)。 short(包装类Short) short数据类型是16位、有符号的以二进制补码表示的整数,最小值是-32768(-2^15)，最大值是32767(2^15 - 1)。 int(包装类Integer) int数据类型是32位、有符号的以二进制补码表示的整数，最小值是-2,147,483,648(-2^31)，最大值是2,147,483,647(2^31 - 1)。 long(包装类Long) long数据类型是64位、有符号的以二进制补码表示的整数，最小值是-9,223,372,036,854,775,808(-2^63)，最大值是9,223,372,036,854,775,807(2^63 -1)。 float(包装类Float) float数据类型是单精度、32位、符合IEEE 754标准的浮点数，浮点数不能用来表示精确的值，如货币。 double(包装类Double) double数据类型是双精度、64位、符合IEEE 754标准的浮点数，double类型同样不能表示精确的值，如货币。 boolean(包装类Boolean) boolean数据类型表示一位的信息，只有两个取值：true和false。 char(包装类Character) char类型是一个单一的16位Unicode字符，最小值是’/u0000’(即为0)，最大值是’/uffff’(即为65,535)。 转义符 变量类型 在 Java 语言中，所有的变量在使用前必须声明。Java 语言支持的变量类型有：局部变量 实例变量 类变量。 局部变量 局部变量声明在方法、构造方法或者语句块中。 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。 访问修饰符不能用于局部变量。 局部变量只在声明它的方法、构造方法或者语句块中可见。 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 实例变量 实例变量声明在一个类中，但在方法、构造方法和语句块之外。 当一个对象被实例化之后，每个实例变量的值就跟着确定。 实例变量在对象创建的时候创建，在对象被销毁的时候销毁。 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。 实例变量可以声明在使用前或者使用后。 访问修饰符可以修饰实例变量。 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见。 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定。 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。 类变量 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法、构造方法和语句块之外。 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。 静态变量除了被声明为常量外很少使用。常量是指声明为 public/private，final 和 static 类型的变量。常量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。 静态变量在程序开始时创建，在程序结束时销毁。 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 静态变量可以通过：ClassName.VariableName 的方式访问。 类变量被声明为 public static final 类型时，类变量名称必须使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。 Java 流(Stream)、文件(File)和IO Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标；一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据；Java为I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。 控制台 Java 的控制台输入由 System.in 完成。为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。 读取多字符输入 从 BufferedReader 对象读取一个字符要使用 read() 方法(int read() throws IOException)。 读取字符串 从标准输入读取一个字符串需要使用 BufferedReader 的 readLine() 方法(String readLine() throws IOException)。 流一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。 目录 创建目录 mkdir( ) 方法创建一个文件夹，成功则返回 true，失败则返回 false；mkdirs( ) 方法创建一个文件夹和它的所有父文件夹。 读取目录 一个目录其实就是一个 File 对象，它包含其他文件和文件夹；可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。 面向对象 重写重载 重写(Override) 重写是子类对父类的允许访问的方法的实现过程进行重新编写！返回值和形参都 &emsp;&emsp;不能改变。即外壳不变，核心重写！&emsp;&emsp;参数列表必须完全与被重写方法的相同。&emsp;&emsp;返回类型必须完全与被重写方法的返回类型相同。&emsp;&emsp;子类方法的访问权限必须大于或等于父类方法的访问权限。&emsp;&emsp;父类的成员方法只能被它的子类重写。&emsp;&emsp;声明为 final 的方法不能被重写。&emsp;&emsp;声明为 static 的方法不能被重写，但是能够被再次声明。&emsp;&emsp;子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。&emsp;&emsp;子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。&emsp;&emsp;重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。&emsp;&emsp;构造方法不能被重写。&emsp;&emsp;如果不能继承一个方法，则不能重写这个方法。 重载(Overload) 重载 (overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同，每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。&emsp;&emsp;被重载的方法必须改变参数列表。&emsp;&emsp;被重载的方法可以改变返回类型。&emsp;&emsp;被重载的方法可以改变访问修饰符。&emsp;&emsp;被重载的方法可以声明新的或更广的检查异常。&emsp;&emsp;方法能够在同一个类中或者在一个子类中被重载。&emsp;&emsp;无法以返回值类型作为重载函数的区分标准。 区别&emsp;&emsp;方法的重写 (Overriding) 和重载 (Overloading) 是 java 多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。&emsp;&emsp;方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载 (Overloading)。&emsp;&emsp;方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写 (Overriding)。&emsp;&emsp;方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。 抽象 抽象类 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。 抽象方法 Abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体，抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号，如果一个类包含抽象方法，那么该类必须是抽象类，任何子类必须重写父类的抽象方法，或者声明自身为抽象类。 封装&emsp;&emsp;在面向对象程式设计方法中，封装（英语：Encapsulation）是指，一种将抽象性函式接口的实作细节部份包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。 接口 接口在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。接口与类相似： 一个接口可以有多个方法。 接口文件保存在.java结尾的文件中，文件名使用接口名。 接口的字节码文件保存在.class结尾的文件中。 接口相应的字节码文件必须在与包名称相匹配的目录结构中。区别： 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了static和final变量。 接口不是被类继承了，而是要被类实现。 接口支持多重继承。 声明 [可见度] interface 接口名称 [extends 其他的类名] {} 实现 public class 类名 implement 接口名称[, 其他接口, 其他接口…, …] 继承 一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。也可多重继承 public interface Hockey extends 接口1, 接口2。 集合框架 序列化 Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。整个过程都是Java虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 序列化对象ObjectOutputStream 类用来序列化一个对象，如下的SerializeDemo例子实例化了一个Employee对象，并将该对象序列化到一个文件中。该程序执行后，就创建了一个名为employee.ser文件。12345678910111213141516171819202122import java.io.*;public class SerializeDemo&#123; public static void main(String [] args)&#123; Employee e &#x3D; new Employee(); e.name &#x3D; &quot;Reyan Ali&quot;; e.address &#x3D; &quot;Phokka Kuan, Ambehta Peer&quot;; e.SSN &#x3D; 11122333; e.number &#x3D; 101; try&#123; FileOutputStream fileOut &#x3D; new FileOutputStream(&quot;&#x2F;tmp&#x2F;employee.ser&quot;); ObjectOutputStream out &#x3D; new ObjectOutputStream(fileOut); out.writeObject(e); out.close(); fileOut.close(); System.out.printf(&quot;Serialized data is saved in &#x2F;tmp&#x2F;employee.ser&quot;); &#125;catch(IOException i)&#123; i.printStackTrace(); &#125; &#125;&#125; 反序列化对象12345678910111213141516171819202122232425import java.io.*;public class DeserializeDemo&#123; public static void main(String [] args)&#123; Employee e &#x3D; null; try&#123; FileInputStream fileIn &#x3D; new FileInputStream(&quot;&#x2F;tmp&#x2F;employee.ser&quot;); ObjectInputStream in &#x3D; new ObjectInputStream(fileIn); e &#x3D; (Employee) in.readObject(); in.close(); fileIn.close(); &#125;catch(IOException i)&#123; i.printStackTrace(); return; &#125;catch(ClassNotFoundException c)&#123; System.out.println(&quot;Employee class not found&quot;); c.printStackTrace(); return; &#125; System.out.println(&quot;Deserialized Employee...&quot;); System.out.println(&quot;Name: &quot; + e.name); System.out.println(&quot;Address: &quot; + e.address); System.out.println(&quot;SSN: &quot; + e.SSN); System.out.println(&quot;Number: &quot; + e.number); &#125;&#125; 多线程 多线程编程&emsp;&emsp;Java 给多线程编程提供了内置的支持。一个多线程程序包含两个或多个能并发运行的部分。程序的每一部分都称作一个线程，并且每个线程定义了一个独立的执行路径。一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守候线程都结束运行后才能结束。 线程生命周期 新建（new Thread） 当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。 就绪（runnable） 线程已经被启动，正在等待被分配给 CPU 时间片，也就是说此时线程正在就绪队列中排队等候得到 CPU 资源。 运行（running） 线程获得 CPU 资源正在执行任务（ run() 方法），此时除非此线程自动放弃 CPU 资源或者有优先级更高的线程进入，线程将一直运行到结束。 堵塞（blocked） 由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。正在睡眠：用 sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。正在等待：调用 wait() 方法。（调用 motify() 方法回到就绪状态）。被另一个线程所阻塞：调用 suspend() 方法。（调用 resume() 方法恢复）。 死亡（dead）当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。自然终止：正常运行 run() 方法后终止。异常终止：调用 stop() 方法让一个线程终止运行。 优先级&emsp;&emsp;每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。Java 优先级在 MIN_PRIORITY（1）和 MAX_PRIORITY（10）之间的范围内。默认情况下，每一个线程都会分配一个优先级NORM_PRIORITY（5）。 Applet基础 applet是一种Java程序。它一般运行在支持Java的Web浏览器内。因为它有完整的Java API支持,所以applet是一个全功能的Java应用程序。Java应用程序和applet程序之间重要的不同： Java中applet类继承了 java.applet.Applet类。 Applet类没有定义main()，所以一个 Applet程序不会调用main()方法。 Applets被设计为嵌入在一个HTML页面。 当用户浏览包含Applet的HTML页面，Applet的代码就被下载到用户的机器上。 要查看一个applet需要JVM。 JVM可以是Web浏览器的一个插件，或一个独立的运行时环境。 用户机器上的JVM创建一个applet类的实例，并调用Applet生命周期过程中的各种方法。 Applets有Web浏览器强制执行的严格的安全规则，applet的安全机制被称为沙箱安全。 applet需要的其他类可以用Java归档（JAR）文件的形式下载下来。 生命周期Applet类中的四个方法提供了一个框架： init: 该方法的目的是为你的applet提供所需的任何初始化。在Applet标记内的param标签被处理后调用该方法。 start: 浏览器调用init方法后，该方法被自动调用。每当用户从其他页面返回到包含Applet的页面时，则调用该方法。 stop:当用户从包含applet的页面移除的时候，该方法自动被调用。因此，可以在相同的applet中反复调用该方法。 destroy: 此方法仅当浏览器正常关闭时调用。因为applets只有在HTML网页上有效，所以你不应该在用户离开包含Applet的页面后遗漏任何资源。 paint: 该方法在start()方法之后立即被调用，或者在applet需要重绘在浏览器的时候调用。paint()方法实际上继承于java.awt。 Applet 类&emsp;&emsp;每一个applet都是java.applet.Applet 类的子类，基础的Applet类提供了供衍生类调用的方法,以此来得到浏览器上下文的信息和服务。这些方法做了如下事情：&emsp;&emsp;得到applet的参数，得到包含applet的HTML文件的网络位置，得到applet类目录的网络位置，打印浏览器的状态信息，获取一张图片，获取一个音频片段，播放一个音频片段，调整此 applet 的大小。&emsp;&emsp;Applet类还提供了一个接口，该接口供Viewer或浏览器来获取applet的信息，并且来控制applet的执行。Viewer可能是：&emsp;&emsp;请求applet作者、版本和版权的信息，请求applet识别的参数的描述，初始化applet，销毁applet，开始执行applet，结束执行applet。 设计模式 分类创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。结构型模式：把类或对象结合在一起形成一个更大的结构。行为型模式：类和对象如何交互，及划分责任和算法。 创建型模式单例模式：某个类只能有一个实例，提供一个全局的访问点。简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。原型模式：通过复制现有的实例来创建新的实例。 结构型模式适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。装饰模式：动态的给对象添加新的功能。代理模式：为其他对象提供一个代理以便控制这个对象的访问。亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。 行为型模式模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。状态模式：允许一个对象在其对象内部状态改变时改变它的行为。观察者模式：对象间的一对多的依赖关系。备忘录模式：在不破坏封装的前提下，保持对象的内部状态。中介者模式：用一个中介对象来封装一系列的对象交互。命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。23种模式 Java项目 微博项目12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Search &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; mysql连接地址，用户名，密码，插入语句 &#x2F;&#x2F; 微博热搜地址 String myUrl &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;weibo?usaSSl&#x3D;false&amp;serverTimezone&#x3D;UTC&quot;; String name &#x3D; &quot;root&quot;; String pwd &#x3D; &quot;156176pwd&quot;; String sql &#x3D; &quot;INSERT INTO search(s_rank,s_title,s_view) VALUES(?,?,?)&quot;; String url &#x3D; &quot;https:&#x2F;&#x2F;s.weibo.com&#x2F;top&#x2F;summary&#x2F;summary?cate&#x3D;realtimehot&quot;; try &#123; &#x2F;&#x2F; 连接数据库 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); Connection connection &#x3D; DriverManager.getConnection(myUrl, name, pwd); &#x2F;&#x2F; 得到微博热搜数据 Document document &#x3D; Jsoup.connect(url).get(); &#x2F;&#x2F; 爬取指定微博热搜数据并储存 Elements r &#x3D; document.select(&quot;td[class&#x3D;&#39;td-01 ranktop&#39;]&quot;); String[] rank &#x3D; r.eachText().toArray(new String[0]); Elements t &#x3D; document.select(&quot;td[class&#x3D;&#39;td-02&#39;] a&quot;); String[] title &#x3D; t.eachText().toArray(new String[0]); Elements v &#x3D; document.select(&quot;span&quot;); String[] view &#x3D; v.eachText().toArray(new String[0]); PreparedStatement statement &#x3D; connection.prepareStatement(sql); statement.setString(1, &quot;top&quot;); statement.setString(2, title[0]); statement.setString(3, &quot;&quot;); statement.executeUpdate(); &#x2F;&#x2F; 插入mysql操作 for (int i &#x3D; 0; i &lt; rank.length; i++) &#123; statement.setString(1, rank[i]); statement.setString(2, title[i + 1]); statement.setString(3, view[i]); statement.executeUpdate(); &#125; &#x2F;&#x2F; 插入mysql操作 connection.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; IDEA使用maven打包javapom配置1234567891011121314151617181920212223242526272829303132&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;3.8.1&lt;&#x2F;version&gt; &lt;&#x2F;plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;&#x2F;artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;com.test.app&lt;&#x2F;mainClass&gt; &lt;&#x2F;manifest&gt; &lt;&#x2F;archive&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;&#x2F;descriptorRef&gt; &lt;&#x2F;descriptorRefs&gt; &lt;&#x2F;configuration&gt; &lt;!--下面是为了使用 mvn package命令，如果不加则使用mvn assembly--&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assemble&lt;&#x2F;id&gt; &lt;phase&gt;package&lt;&#x2F;phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;&#x2F;goal&gt; &lt;&#x2F;goals&gt; &lt;&#x2F;execution&gt; &lt;&#x2F;executions&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt;&lt;&#x2F;build&gt; 单独记录Mysql 索引 定义&emsp;&emsp;索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。(相当于目录，根据页码找内容) 分类 普通索引&emsp;&emsp;普通索引是最基本的索引类型，唯一任务是加快对数据的访问速度，没有任何限制。创建普通索引时，通常使用的关键字是 INDEX 或 KEY。 唯一性索引&emsp;&emsp;唯一性索引是不允许索引列具有相同索引值的索引。如果能确定某个数据列只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字 UNIQUE 把它定义为一个唯一性索引。 主键索引&emsp;&emsp;主键索引是一种唯一性索引，即不允许值重复或者值为空，并且每个表只能有一个主键。主键可以在创建表的时候指定，也可以通过修改表的方式添加，必须指定关键字 PRIMARY KEY。 空间索引&emsp;&emsp;空间索引主要用于地理空间数据类型 GEOMETRY。 全文索引&emsp;&emsp;全文索引只能在 VARCHAR 或 TEXT 类型的列上创建，并且只能在 MyISAM 表中创建。 执行计划&emsp;&emsp;执行计划，就是一条SQL语句，在数据库中实际执行的时候，一步步的分别都做了什么。 事务&emsp;&emsp;事务是逻辑上的一组操作，组成这组操作的各个单元，要不全都成功要不全都失败，这个特性就是事务。 幻读、脏读和不可重复读 幻读&emsp;&emsp;在一次事务里面，多次查询之后，结果集的个数不一致的情况叫做幻读。而多出来或者少的哪一行被叫做幻行。 脏读&emsp;&emsp;脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。 不可重复读&emsp;&emsp;在同一事务中，两次读取同一数据，得到内容不同。 主键&emsp;&emsp;主键是数据表的唯一索引，指的是一个列或多列的组合，其值能唯一地标识表中的每一行，通过它可强制表的实体完整性，主键主要是用与其他表的外键关联，以及本记录的修改与删除。 视图&emsp;&emsp;视图是一种虚拟存在的表，是一个逻辑表，本身并不包含数据，作为一个select语句保存在数据字典中的。Java 发展历史 1995年5月23日，Java语言诞生 1996年1月，第一个JDK-JDK1.0诞生 1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术 1996年9月，约8.3万个网页应用了JAVA技术来制作 1997年2月18日，JDK1.1发布 1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录 1997年9月，JavaDeveloperConnection社区成员超过十万 1998年2月，JDK1.1被下载超过2,000,000次 1998年12月8日，JAVA2企业平台J2EE发布 1999年6月，SUN公司发布Java的三个版本：标准版（JavaSE,以前是J2SE）、企业版（JavaEE以前是J2EE）和微型版（JavaME，以前是J2ME） 2000年5月8日，JDK1.3发布 2000年5月29日，JDK1.4发布 2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机 2001年9月24日，J2EE1.3发布 2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升 2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0 2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字”2”：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME 2006年12月，SUN公司发布JRE6.0 2009年04月20日，甲骨文74亿美元收购Sun。取得java的版权。 2010年11月，由于甲骨文对于Java社区的不友善，因此Apache扬言将退出JCP。 2011年7月28日，甲骨文发布java7.0的正式版。 命名规范 包命名全小写，由域名定义，一般采用自己在互联网上的域名(com.jianguo.service)。 类名每个单词首字母大写(TestTime)。 方法名首字母小写后面其他单词首字母大写(public static void openFile(){})。 常量名全部大写常加”_”，并指出完整定义，多个单词组成用下划线分隔(public static final int NUMBER=0)。 参数名与方法命名相同，尽量用一个单词(public void test(String str)中str)。 变量命名 camel标记法：首字母小写，后面单词都以大写字母开头。 pascal标记法：首字母大写，后面单词首字母大写。 匈牙利标记法：在以pascal标记法的变量前附加小写序列说明变量类型(scope_typeVariableName)。 Java bean JavaBean 是一种JAVA语言写成的可重用组件，为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器，JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性。 JavaBean可分为两种：&emsp;&emsp;一种是有用户界面（UI，User Interface）的JavaBean；还有一种是没有用户界面，主要负责处理事务（如数据运算，操纵数据库）的JavaBean。 多态和继承 多态&emsp;&emsp;多态是同一个行为具有多个不同表现形式或形态的能力，是对象多种表现形式的体现(动物有很多种：狗，毛，鱼等)。 继承&emsp;&emsp;继承是面向对象最显著的一个特性,是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力,是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。 Java mvc MVC 模式代表 Model-View-Controller(模型-视图-控制器)模式 Model(模型)：模型代表一个存取数据的对象或 JAVA POJO,它也可以带有逻辑，在数据变化时更新控制器。 View(视图)：视图代表模型包含的数据的可视化。 异常处理 异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。 异常发生的原因有很多，通常包含以下几大类： 用户输入了非法数据。 要打开的文件不存在。 网络通信时连接中断，或者JVM内存溢出。 Exception类的层次&emsp;&emsp;Exception 类是 Throwable 类的子类,有两个主要的子类：IOException 类和 RuntimeException 类。异常处理 Java 注解开发 注解作用&emsp;&emsp;用于告诉编译器javac或工具软件传达一种信息,相当于一个标记，加了注解就等于打上了某种标记，没加就等于没有某种标记，以后，javac编译器，开发工具和其他程序可以用反射来了解你的类及各种元素上有无何种标记，看你有什么标记就去干相应的事,标记可以加在包、类、方法、字段、方法的参数及局部变量上。 基本注解&emsp;&emsp;Deprecated过时的,FunctionalInterface函数式接口：一种特殊类型的接口，这种接口中只定义了唯一的抽象方法的接口，Override 覆盖 ，SafeVarargs 可变参数安全性注解，SuppressWarnings过滤警告注解。 元注解 @Retention标记注解的生命周期，三种取值分别为：RetentionPolicy.SOURCE RetentionPolicy.CLASS RetentionPolicy.RUNNTIME 分别对应：源文件注解，class文件注解，内存中字节码，默认值是在class阶段@Override是在编译阶段覆盖的，因此它的Retention是source @SuppressWarnings也是source Deprecated是runtime 。 @Target 标记给哪个元素添加注解取值分别为ElementType.Annotation_Type ElementType.Constructor ElementType.FIELD等等。","categories":[],"tags":[]}],"categories":[],"tags":[]}