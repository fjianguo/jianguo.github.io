<hr>
<p>title: 学习总结 # 标题<br>date: 2020/10/16 hh:mm:ss # 时间<br>categories: # 分类</p>
<ul>
<li>Diary<br>tags: # 标签</li>
<li>PS3</li>
<li>Games</li>
</ul>
<hr>
<p>摘要</p>
<!--more-->
<p>正文</p>
<div align = "center" ><font size='50'>学习总结</font></div>  

<p>[TOC]</p>
<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><ol>
<li><p>shell命令  </p>
<ul>
<li><p>编辑文件 vi 文件名</p>
</li>
<li><p>复制文件 cp a文件 b文件 将a文件复制一份，b就是复制文件(副本)。</p>
</li>
<li><p>复制文件目录 cp a目录 b目录 -r 将a目录(包含里面的全部文件)内容 复制到b目录下，-r 递归复制。</p>
</li>
<li><p>新建文件 touch 文件名 文件不存在就新建，存在就更新新建的最新修改时间。</p>
</li>
<li><p>移动文件 mv a文件 b目录 将a文件移动到b目录下。</p>
</li>
<li><p>重命名文件 mv a文件 b文件 将a文件命名为b文件。</p>
</li>
<li><p>删除文件 rm a文件</p>
</li>
<li><p>删除文件目录 rm a目录 -r</p>
</li>
<li><p>显示文本内容 cat 文件名</p>
</li>
<li><p>显示字符串 echo “hello” echo hello &gt;&gt; 文件名(向文件中写入hello，如没有文件则创建文件并写入)。</p>
</li>
<li><p>查找文件 find 目录 -name “*.sh” 找出目录下的所有.sh文件</p>
</li>
<li><p>查找字符串 grep “abc”目录 目录中找字符串 “abc”。</p>
</li>
<li><p>列出文件信息 ls 列出当前目录文件信息。</p>
</li>
<li><p>创建目录 mkdir 目录名</p>
</li>
<li><p>显示当前路径 pwd</p>
</li>
<li><p>定时执行 crontab：* * * * * 执行语句每个”*”对应：分，时，日，月，星期。</p>
</li>
<li><p>shell项目</p>
<pre><code>  while (( 0 == 0 ))
do
dir_name=$(date &#39;+%M&#39;)
  python3 &lt;&lt;EOF
import sys
from time import sleep
sleep(10)
EOF  //暂停10秒
# 调用makeF函数
runmake=$(makeF $dir_name)
echo $runmake
# 调用timeF函数
runtime=$(timeF $dir_name)
echo $runtime
done

function makeF(){

  [ -d /mnt/f/WorkSpace/$1 ] ||{
  mkdir /mnt/f/WorkSpace/$1
  } # 查询有无文件夹，无则创建，否则不创建
  [ -d /mnt/f/WorkSpace/$1/$1 ] ||{
  touch /mnt/f/WorkSpace/$1/$1  
  } # 查询有无文件，无则创建，否则不创建
}

function timeF(){
  echo $(date +%s) &gt;&gt; /mnt/f/WorkSpace/$1/$1 # 向文件中写如当前时间戳
}</code></pre>
<h1 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h1><p><a href="https://www.w3cschool.cn/python3/">Python3</a></p>
</li>
</ul>
</li>
<li><p>基本数据类型</p>
<ul>
<li>Numbers(数字)<br>Python 3支持int、float、bool、complex(复数)。</li>
</ul>
<ol>
<li>Python可以同时为多个变量赋值  </li>
<li>一个变量可以通过赋值指向不同类型的对象。</li>
<li>数值的除法（/）总是返回一个浮点数，要获取整数使用//操作符。  </li>
<li>在混合计算时，Pyhton会把整型转换成为浮点数。</li>
</ol>
<ul>
<li>String(字符)<br>Python中的字符串str用单引号(‘ ‘)或双引号(“ “)括起来。</li>
</ul>
<ol>
<li>反斜杠可以用来转义，使用r可以让反斜杠不发生转义(print(‘C:\some\name’),print(r’C:\some\name’))。</li>
<li>字符串可以用+运算符连接在一起，用*运算符重复(print(‘str’+’ing’,’x’*4))。</li>
<li>Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。</li>
<li>Python中的字符串不能改变。</li>
</ol>
<ul>
<li>List(列表)<br>List(列表)是 Python 中使用最频繁的数据类型。</li>
</ul>
<ol>
<li>List写在方括号之间，元素用逗号隔开。</li>
<li>和字符串一样，list可以被索引和切片。</li>
<li>List可以使用+操作符进行拼接。</li>
<li>List中的元素是可以改变的。</li>
</ol>
<ul>
<li>Tuple(元组)<br>元组(tuple)与列表类似，不同之处在于元组的元素不能修改。元组写在小括号里，元素之间用逗号隔开。</li>
</ul>
<ol>
<li>与字符串一样，元组的元素不能修改。</li>
<li>元组也可以被索引和切片，方法一样。</li>
<li>注意构造包含0或1个元素的元组的特殊语法规则。</li>
<li>元组也可以使用+操作符进行拼接。</li>
</ol>
<ul>
<li>Sets(集合)<br>集合(set)是一个无序不重复元素的集,基本功能是进行成员关系测试和消除重复元素,可以使用大括号 或者 set()函数创建set集合。</li>
<li>Dictionaries(字典)<br>字典（dictionary）是Python中另一个非常有用的内置数据类型,是一种映射类型(mapping type)，它是一个无序的键 : 值对集合。</li>
</ul>
<ol>
<li>字典是一种映射类型，它的元素是键值对。</li>
<li>字典的关键字必须为不可变类型，且不能重复。</li>
<li>创建空字典使用{}。</li>
</ol>
</li>
<li><p>运算符</p>
<ul>
<li>算术运算符<br><img src="image%5C%E8%BF%90%E7%AE%97%E7%AC%A6.jpg" alt="运算符">  </li>
<li>比较符<br><img src="image%5C%E6%AF%94%E8%BE%83%E7%AC%A6.jpg" alt="比较符">  </li>
<li>赋值符<br><img src="image%5C%E8%B5%8B%E5%80%BC%E7%AC%A6.jpg" alt="赋值符">  </li>
<li>位运算符<br><img src="image%5C%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6.jpg" alt="位运算">  </li>
<li>逻辑运算符<br><img src="image%5C%E9%80%BB%E8%BE%91.jpg" alt="逻辑">  </li>
<li>成员运算符<br><img src="image%5C%E6%88%90%E5%91%98.jpg" alt="成员">  </li>
<li>身份运算符<br><img src="image%5C%E8%BA%AB%E4%BB%BD.jpg" alt="身份">  </li>
<li>优先级<br><img src="image%5C%E4%BC%98%E5%85%88%E7%BA%A7.jpg" alt="优先级">  </li>
</ul>
</li>
<li><p>Python3项目  </p>
<ul>
<li>微博热搜<pre><code>#!/usr/bin/python3
#encoding=utf-8
###导入模块
import requests
from lxml import etree
import pymysql

</code></pre>
</li>
</ul>
</li>
</ol>
<pre><code>def weibo():
    #配置数据库
    config = {
        &#39;host&#39;:&#39;127.0.0.1&#39;,
        &#39;port&#39;:3306,
        &#39;user&#39;:&#39;root&#39;,
        &#39;password&#39;:&#39;q1561762345&#39;,
        &#39;db&#39;:&#39;weibo&#39;,
        &#39;charset&#39;:&#39;utf8&#39;,
        }
    #链接数据库
    conn=pymysql.connect(**config)
    cursor=conn.cursor()
    &#39;&#39;&#39;
    微博热搜榜 实时抓取微博的排行榜!需要设置请求头headers!
    &#39;&#39;&#39;
    headers = {
        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36 QIHU 360SE&#39;
    }
    url = &#39;https://s.weibo.com/top/summary/summary?cate=realtimehot&#39;
    # 获取html页面
    html = etree.HTML(requests.get(url,headers=headers).text)
    print(html)
    # 查找指定元素 所有的
    rank = html.xpath(&#39;//td[@class=&quot;td-01 ranktop&quot;]/text()&#39;)
    txt = html.xpath(&#39;//td[@class=&quot;td-02&quot;]/a/text()&#39;)
    view = html.xpath(&#39;//td[@class=&quot;td-02&quot;]/span/text()&#39;)
    top = txt[0]
    txt = txt[1:]
    print(&#39;top&#39; + &#39;\t&#39; + top + &#39;\t&#39; + str(view[0]))
    sql=&#39;insert into resou (r_rank,r_text,r_view) values (%s,%s,%s)&#39;
    cursor.execute(sql,(&#39;top&#39;,top,view[0]))
    conn.commit()
    for x in range(0,len(view)):
        print(str(rank[x]) + &#39;\t&#39; + str(txt[x]) + &#39;\t&#39; + str(view[x]))
        sql=&#39;insert into resou (r_rank,r_text,r_view) values (%s,%s,%s)&#39;
        cursor.execute(sql,(rank[x],txt[x],view[x]))
        conn.commit()
    cursor.close()
    conn.close()

if __name__ == &#39;__main__&#39;:
    weibo()
```
- 百度文字识别
```
#!/usr/bin/python3
# -*- coding: UTF-8 -*-
from aip import AipOcr
import pymysql

#配置数据库
config = {
        &#39;host&#39;:&#39;127.0.0.1&#39;,
        &#39;port&#39;:3306,
        &#39;user&#39;:&#39;root&#39;,
        &#39;password&#39;:&#39;q1561762345&#39;,
        &#39;db&#39;:&#39;baidu&#39;,
        &#39;charset&#39;:&#39;utf8&#39;,
        }
#链接数据库
conn=pymysql.connect(**config)
cursor=conn.cursor()
&#39;&#39;&#39; APPID AK SK &#39;&#39;&#39;
APP_ID = &#39;22240664&#39;
API_KEY = &#39;uhO3u1hRCRHefQqMG90PVSyw&#39;
SECRET_KEY = &#39;wG3QXaqGfd6TiwVSN0vxCyi5muwI0EGi&#39;
# 初始化AipFace对象
client = AipOcr(APP_ID,API_KEY,SECRET_KEY)
def get_file_content(filePath):
    with open(filePath,&#39;rb&#39;) as fp:
        return fp.read()
# 读取图片
# 定义参数变量
options = {
    &#39;detect_direction&#39;: &#39;true&#39;,
    &#39;language_type&#39;: &#39;CHN_ENG&#39;,
}
# 调用通用文字识别接口
def addImage(image):
    def addOptions(options):
        return client.basicGeneral(image,options)
    return addOptions
image = get_file_content(&#39;C:\\Users\\Administrator\\Desktop\\头条\\AI\\example.png&#39;)
addOption = addImage(image)
result = addOption(options)
result = result[&#39;words_result&#39;]
text = &#39;&#39;
name = &#39;&#39;
n = 0
for i in result:
    value, = i.values()
    if n == 0:
        name = value
        n = n + 1
    else:
        text = text + value
sql=&#39;insert into kapian (k_name,k_text) values (%s,%s)&#39;
cursor.execute(sql,(name,text))
conn.commit()
cursor.close()
conn.close()
```</code></pre>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><p><a href="https://www.w3cschool.cn/mysql/">Mysql</a></p>
<ol>
<li><p>Mysql 连接<br>&emsp;&emsp;mysql -u root -p 登录mysql 其中root表示用户，exit退出mysql</p>
</li>
<li><p>基本类型</p>
<ul>
<li>MySQL 支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</li>
</ul>
<ol>
<li>数值类型<br><a href="image%5C%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B.jpg">数值类型</a>  </li>
<li>日期/时间类型<br><a href="image%5C%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B.jpg">日期时间类型</a>  </li>
<li>字符串类型<br><a href="image%5C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B.jpg">字符串类型</a>  </li>
</ol>
</li>
<li><p>数据库操作</p>
<ul>
<li>创建<br>mysql命令create database 数据库名称，DOS命令mysqladmin -u root -p create 数据库名称 登录mysql并创建数据库。</li>
<li>删除<br>mysql命令drop database 想要删除的数据库名称，DOS命令mysqladmin -u root -p drop 想要删除的数据库名称 登录mysql并删除数据库(需确认)。</li>
<li>选择<br>mysql命令use 想要选择的数据库名称，DOS命令需先登录mysql再use 想要选择的数据库名称。</li>
<li>show databases; 可查看以拥有数据库。</li>
</ul>
</li>
<li><p>数据表操作</p>
<ul>
<li>创建<pre><code>create table 表名称(
  id int not null auto_increment,
  name1 varchar(100) not null,
  name2 varchar(40) not null,
  primary key (id)
)</code></pre>
</li>
</ul>
<ol>
<li>AUTO_INCREMENT定义列为自增的属性,每次加1。</li>
<li>PRIMARY KEY关键字用于定义列为主键。</li>
<li>不想字段为 NULL 可以设置字段的属性为 NOT NULL，输入null会报错。</li>
</ol>
<ul>
<li>删除</li>
</ul>
<ol>
<li>删除表：drop table 想要删除的表名。</li>
<li>删除内容：delete from 表名 [where 条件]，无where则删除全部内容，truncate 表名 删除全部数据。</li>
</ol>
<ul>
<li>插入数据<br>insert into 表名(字段名) values(要插入的数据)，其中字段名可以是多个，用逗号隔开，数据要对应字段数量。</li>
<li>查询数据<br>select 查询字段名 from 表名 [where 条件]；无where得到表中所有指定字段数据，查询表中所有数据字段名用”*”表示。</li>
<li>修改数据<br>update 表名 set 字段名=新数据 [where 条件]；无where修改表中所有指定字段的值位新数据，字段名可为多个用逗号隔开。</li>
</ul>
</li>
<li><p>正则表达式<br><img src="image%5C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg" alt="正则表达式"></p>
</li>
<li><p>alter命令</p>
<ul>
<li>删除、添加修改字段</li>
</ul>
<ol>
<li>ALTER TABLE 表名  DROP 字段名; 删除字段。</li>
<li>ALTER TABLE 表名 ADD 字段名 INT; 添加字段。</li>
<li>ALTER TABLE 表名 DROP 字段名; ALTER TABLE 表名 ADD 字段名 INT FIRST; first表示添加到首列，也可用数值代替，数字不能大于字段数量。</li>
</ol>
<ul>
<li>修改字段及名称</li>
</ul>
<ol>
<li>ALTER TABLE 表名 MODIFY 要修改的字段名 类型; 修改字类型。</li>
<li>ALTER TABLE 表名 CHANGE 要修改的字段名 修改后的字段名 类型; 修改字段名及类型，前后两个字段名相同只修改类型。</li>
<li>ALTER TABLE 表名 MODIFY 字段名 类型 NOT NULL DEFAULT 默认值; 修改默认值或是否不能为null。</li>
</ol>
<ul>
<li>修改表名<br>ALTER TABLE 表名 RENAME TO 新表名;<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><a href="https://www.w3cschool.cn/java/">Java</a></li>
</ul>
</li>
<li><p>基础语法</p>
<ul>
<li>Java大小写敏感，类名首字母大写且每个单词首字母都要大写，方法名首字母小写其他同类名，源文件名必须和类名相同且后缀为.java，所有的Java 程序由public static void main(String[] args)方法开始执行。</li>
<li>标识符：以大小写字母、$、_开始，后面可跟任何字符，关键字不能当标识符，大小写敏感。</li>
<li>修饰符：访问控制修饰符 : default, public , protected, private,非访问控制修饰符 : final, abstract, static，synchronized 和 volatile。</li>
<li>关键字<br><img src="image%5C%E5%85%B3%E9%94%AE%E5%AD%97.jpg" alt="关键字"></li>
</ul>
</li>
<li><p>基本数据类型</p>
<ul>
<li>Java语言提供了八种基本类型。六种数字类型(四个整数型，两个浮点型)，一种字符类型，还有一种布尔型。  </li>
</ul>
<ol>
<li>byte(包装类Byte) byte数据类型是8位、有符号的，以二进制补码表示的整数，最小值是-128(-2^7)，最大值是127(2^7-1)。</li>
<li>short(包装类Short) short数据类型是16位、有符号的以二进制补码表示的整数,最小值是-32768(-2^15)，最大值是32767(2^15 - 1)。</li>
<li>int(包装类Integer) int数据类型是32位、有符号的以二进制补码表示的整数，最小值是-2,147,483,648(-2^31)，最大值是2,147,483,647(2^31 - 1)。</li>
<li>long(包装类Long) long数据类型是64位、有符号的以二进制补码表示的整数，最小值是-9,223,372,036,854,775,808(-2^63)，最大值是9,223,372,036,854,775,807(2^63 -1)。</li>
<li>float(包装类Float) float数据类型是单精度、32位、符合IEEE 754标准的浮点数，浮点数不能用来表示精确的值，如货币。</li>
<li>double(包装类Double) double数据类型是双精度、64位、符合IEEE 754标准的浮点数，double类型同样不能表示精确的值，如货币。</li>
<li>boolean(包装类Boolean) boolean数据类型表示一位的信息，只有两个取值：true和false。</li>
<li>char(包装类Character) char类型是一个单一的16位Unicode字符，最小值是’\u0000’(即为0)，最大值是’\uffff’(即为65,535)。</li>
<li>转义符<br><img src="image%5C%E8%BD%AC%E4%B9%89%E7%AC%A6.jpg" alt="转义符"></li>
</ol>
</li>
<li><p>变量类型</p>
<ul>
<li>在 Java 语言中，所有的变量在使用前必须声明。Java 语言支持的变量类型有：局部变量 实例变量 类变量。</li>
<li>局部变量</li>
</ul>
<ol>
<li>局部变量声明在方法、构造方法或者语句块中。</li>
<li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。</li>
<li>访问修饰符不能用于局部变量。</li>
<li>局部变量只在声明它的方法、构造方法或者语句块中可见。</li>
<li>局部变量是在栈上分配的。</li>
<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li>
</ol>
<ul>
<li>实例变量  </li>
</ul>
<ol>
<li>实例变量声明在一个类中，但在方法、构造方法和语句块之外。</li>
<li>当一个对象被实例化之后，每个实例变量的值就跟着确定。</li>
<li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁。</li>
<li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。</li>
<li>实例变量可以声明在使用前或者使用后。</li>
<li>访问修饰符可以修饰实例变量。</li>
<li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见。</li>
<li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定。</li>
<li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</li>
</ol>
<ul>
<li>类变量</li>
</ul>
<ol>
<li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法、构造方法和语句块之外。</li>
<li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li>
<li>静态变量除了被声明为常量外很少使用。常量是指声明为 public/private，final 和 static 类型的变量。常量初始化后不可改变。</li>
<li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。</li>
<li>静态变量在程序开始时创建，在程序结束时销毁。</li>
<li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</li>
<li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li>
<li>静态变量可以通过：ClassName.VariableName 的方式访问。</li>
<li>类变量被声明为 public static final 类型时，类变量名称必须使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。</li>
</ol>
</li>
<li><p>Java 流(Stream)、文件(File)和IO  </p>
<ul>
<li>Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标；一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据；Java为I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。</li>
<li>控制台 Java 的控制台输入由 System.in 完成。为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。</li>
</ul>
<ol>
<li>读取多字符输入 从 BufferedReader 对象读取一个字符要使用 read() 方法(int read() throws IOException)。</li>
<li>读取字符串 从标准输入读取一个字符串需要使用 BufferedReader 的 readLine() 方法(String readLine() throws IOException)。</li>
</ol>
<ul>
<li>流<br>一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。<br><img src="image%5C%E6%B5%81.jpg" alt="流"></li>
<li>目录  </li>
</ul>
<ol>
<li>创建目录 mkdir( ) 方法创建一个文件夹，成功则返回 true，失败则返回 false；mkdirs( ) 方法创建一个文件夹和它的所有父文件夹。</li>
<li>读取目录 一个目录其实就是一个 File 对象，它包含其他文件和文件夹；可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。</li>
</ol>
</li>
<li><p>面向对象</p>
<ul>
<li>重写重载</li>
</ul>
<ol>
<li>重写(Override) 重写是子类对父类的允许访问的方法的实现过程进行重新编写！返回值和形参都 &emsp;&emsp;不能改变。即外壳不变，核心重写！<br>&emsp;&emsp;参数列表必须完全与被重写方法的相同。<br>&emsp;&emsp;返回类型必须完全与被重写方法的返回类型相同。<br>&emsp;&emsp;子类方法的访问权限必须大于或等于父类方法的访问权限。<br>&emsp;&emsp;父类的成员方法只能被它的子类重写。<br>&emsp;&emsp;声明为 final 的方法不能被重写。<br>&emsp;&emsp;声明为 static 的方法不能被重写，但是能够被再次声明。<br>&emsp;&emsp;子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。<br>&emsp;&emsp;子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。<br>&emsp;&emsp;重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。<br>&emsp;&emsp;构造方法不能被重写。<br>&emsp;&emsp;如果不能继承一个方法，则不能重写这个方法。</li>
<li>重载(Overload) 重载 (overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同，每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。<br>&emsp;&emsp;被重载的方法必须改变参数列表。<br>&emsp;&emsp;被重载的方法可以改变返回类型。<br>&emsp;&emsp;被重载的方法可以改变访问修饰符。<br>&emsp;&emsp;被重载的方法可以声明新的或更广的检查异常。<br>&emsp;&emsp;方法能够在同一个类中或者在一个子类中被重载。<br>&emsp;&emsp;无法以返回值类型作为重载函数的区分标准。</li>
<li>区别<br>&emsp;&emsp;方法的重写 (Overriding) 和重载 (Overloading) 是 java 多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。<br>&emsp;&emsp;方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载 (Overloading)。<br>&emsp;&emsp;方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写 (Overriding)。<br>&emsp;&emsp;方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li>
</ol>
<ul>
<li>抽象  </li>
</ul>
<ol>
<li>抽象类 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。</li>
<li>抽象方法 Abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体，抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号，如果一个类包含抽象方法，那么该类必须是抽象类，任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li>
</ol>
<ul>
<li>封装<br>&emsp;&emsp;在面向对象程式设计方法中，封装（英语：Encapsulation）是指，一种将抽象性函式接口的实作细节部份包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</li>
<li>接口  </li>
</ul>
<ol>
<li>接口在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。<br>接口与类相似：<ul>
<li>一个接口可以有多个方法。</li>
<li>接口文件保存在.java结尾的文件中，文件名使用接口名。</li>
<li>接口的字节码文件保存在.class结尾的文件中。</li>
<li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。<br>区别：</li>
<li>接口不能用于实例化对象。</li>
<li>接口没有构造方法。</li>
<li>接口中所有的方法必须是抽象方法。</li>
<li>接口不能包含成员变量，除了static和final变量。</li>
<li>接口不是被类继承了，而是要被类实现。</li>
<li>接口支持多重继承。</li>
</ul>
</li>
<li>声明 [可见度] interface 接口名称 [extends 其他的类名] {}</li>
<li>实现 public class 类名 implement 接口名称[, 其他接口, 其他接口…, …]</li>
<li>继承 一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。也可多重继承 public interface Hockey extends 接口1, 接口2。</li>
</ol>
<ul>
<li><a href="https://www.w3cschool.cn/java/java-collections.html">集合框架</a></li>
<li>序列化</li>
</ul>
<ol>
<li><p>Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。整个过程都是Java虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。</p>
</li>
<li><p>序列化对象<br>ObjectOutputStream 类用来序列化一个对象，如下的SerializeDemo例子实例化了一个Employee对象，并将该对象序列化到一个文件中。该程序执行后，就创建了一个名为employee.ser文件。</p>
<pre><code>import java.io.*;

public class SerializeDemo{
 public static void main(String [] args){
     Employee e = new Employee();
     e.name = &quot;Reyan Ali&quot;;
     e.address = &quot;Phokka Kuan, Ambehta Peer&quot;;
     e.SSN = 11122333;
     e.number = 101;
     try{
         FileOutputStream fileOut =
         new FileOutputStream(&quot;/tmp/employee.ser&quot;);
         ObjectOutputStream out = new ObjectOutputStream(fileOut);
         out.writeObject(e);
         out.close();
         fileOut.close();
         System.out.printf(&quot;Serialized data is saved in /tmp/employee.ser&quot;);
     }catch(IOException i){
         i.printStackTrace();
     }
 }
}</code></pre>
</li>
<li><p>反序列化对象</p>
<pre><code>import java.io.*;
public class DeserializeDemo{
 public static void main(String [] args){
     Employee e = null;
     try{
         FileInputStream fileIn = new FileInputStream(&quot;/tmp/employee.ser&quot;);
         ObjectInputStream in = new ObjectInputStream(fileIn);
         e = (Employee) in.readObject();
         in.close();
         fileIn.close();
     }catch(IOException i){
         i.printStackTrace();
         return;
     }catch(ClassNotFoundException c){
         System.out.println(&quot;Employee class not found&quot;);
         c.printStackTrace();
         return;
     }
     System.out.println(&quot;Deserialized Employee...&quot;);
     System.out.println(&quot;Name: &quot; + e.name);
     System.out.println(&quot;Address: &quot; + e.address);
     System.out.println(&quot;SSN: &quot; + e.SSN);
     System.out.println(&quot;Number: &quot; + e.number);
 }
}</code></pre>
</li>
</ol>
<ul>
<li>多线程</li>
</ul>
<ol>
<li>多线程编程<br>&emsp;&emsp;Java 给多线程编程提供了内置的支持。一个多线程程序包含两个或多个能并发运行的部分。程序的每一部分都称作一个线程，并且每个线程定义了一个独立的执行路径。一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守候线程都结束运行后才能结束。</li>
<li>线程生命周期<br><img src="image%5C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="生命周期"><ul>
<li>新建（new Thread） 当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。</li>
<li>就绪（runnable） 线程已经被启动，正在等待被分配给 CPU 时间片，也就是说此时线程正在就绪队列中排队等候得到 CPU 资源。</li>
<li>运行（running） 线程获得 CPU 资源正在执行任务（ run() 方法），此时除非此线程自动放弃 CPU 资源或者有优先级更高的线程进入，线程将一直运行到结束。</li>
<li>堵塞（blocked） 由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。<br>正在睡眠：用 sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。<br>正在等待：调用 wait() 方法。（调用 motify() 方法回到就绪状态）。<br>被另一个线程所阻塞：调用 suspend() 方法。（调用 resume() 方法恢复）。</li>
<li>死亡（dead）当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。<br>自然终止：正常运行 run() 方法后终止。<br>异常终止：调用 stop() 方法让一个线程终止运行。</li>
</ul>
</li>
<li>优先级<br>&emsp;&emsp;每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。Java 优先级在 MIN_PRIORITY（1）和 MAX_PRIORITY（10）之间的范围内。默认情况下，每一个线程都会分配一个优先级NORM_PRIORITY（5）。</li>
</ol>
<ul>
<li>Applet基础  </li>
</ul>
<ol>
<li>applet是一种Java程序。它一般运行在支持Java的Web浏览器内。因为它有完整的Java API支持,所以applet是一个全功能的Java应用程序。<br>Java应用程序和applet程序之间重要的不同：<ul>
<li>Java中applet类继承了 java.applet.Applet类。</li>
<li>Applet类没有定义main()，所以一个 Applet程序不会调用main()方法。</li>
<li>Applets被设计为嵌入在一个HTML页面。</li>
<li>当用户浏览包含Applet的HTML页面，Applet的代码就被下载到用户的机器上。</li>
<li>要查看一个applet需要JVM。 JVM可以是Web浏览器的一个插件，或一个独立的运行时环境。</li>
<li>用户机器上的JVM创建一个applet类的实例，并调用Applet生命周期过程中的各种方法。</li>
<li>Applets有Web浏览器强制执行的严格的安全规则，applet的安全机制被称为沙箱安全。</li>
<li>applet需要的其他类可以用Java归档（JAR）文件的形式下载下来。</li>
</ul>
</li>
<li>生命周期<br>Applet类中的四个方法提供了一个框架：<ul>
<li>init: 该方法的目的是为你的applet提供所需的任何初始化。在Applet标记内的param标签被处理后调用该方法。</li>
<li>start: 浏览器调用init方法后，该方法被自动调用。每当用户从其他页面返回到包含Applet的页面时，则调用该方法。</li>
<li>stop:当用户从包含applet的页面移除的时候，该方法自动被调用。因此，可以在相同的applet中反复调用该方法。</li>
<li>destroy: 此方法仅当浏览器正常关闭时调用。因为applets只有在HTML网页上有效，所以你不应该在用户离开包含Applet的页面后遗漏任何资源。</li>
<li>paint: 该方法在start()方法之后立即被调用，或者在applet需要重绘在浏览器的时候调用。paint()方法实际上继承于java.awt。</li>
</ul>
</li>
<li>Applet 类<br>&emsp;&emsp;每一个applet都是java.applet.Applet 类的子类，基础的Applet类提供了供衍生类调用的方法,以此来得到浏览器上下文的信息和服务。<br>这些方法做了如下事情：<br>&emsp;&emsp;得到applet的参数，得到包含applet的HTML文件的网络位置，得到applet类目录的网络位置，打印浏览器的状态信息，获取一张图片，获取一个音频片段，播放一个音频片段，调整此 applet 的大小。<br>&emsp;&emsp;Applet类还提供了一个接口，该接口供Viewer或浏览器来获取applet的信息，并且来控制applet的执行。<br>Viewer可能是：<br>&emsp;&emsp;请求applet作者、版本和版权的信息，请求applet识别的参数的描述，初始化applet，销毁applet，开始执行applet，结束执行applet。</li>
</ol>
<ul>
<li>设计模式</li>
</ul>
<ol>
<li>分类<br>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。<br>结构型模式：把类或对象结合在一起形成一个更大的结构。<br>行为型模式：类和对象如何交互，及划分责任和算法。</li>
<li>创建型模式<br>单例模式：某个类只能有一个实例，提供一个全局的访问点。<br>简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。<br>工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。<br>抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。<br>建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。<br>原型模式：通过复制现有的实例来创建新的实例。  </li>
<li>结构型模式<br>适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。<br>组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。<br>装饰模式：动态的给对象添加新的功能。<br>代理模式：为其他对象提供一个代理以便控制这个对象的访问。<br>亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。<br>外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。<br>桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。  </li>
<li>行为型模式<br>模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。<br>解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。<br>策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。<br>状态模式：允许一个对象在其对象内部状态改变时改变它的行为。<br>观察者模式：对象间的一对多的依赖关系。<br>备忘录模式：在不破坏封装的前提下，保持对象的内部状态。<br>中介者模式：用一个中介对象来封装一系列的对象交互。<br>命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。<br>访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。<br>责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。<br>迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。<br><a href="https://www.w3cschool.cn/java/java-factory-pattern.html">23种模式</a></li>
</ol>
<ul>
<li>Java项目</li>
</ul>
<ol>
<li><p>微博项目</p>
<pre><code>public class Search {

 public static void main(String[] args) {
     // mysql连接地址，用户名，密码，插入语句
     // 微博热搜地址
     String myUrl = &quot;jdbc:mysql://localhost:3306/weibo?usaSSl=false&amp;serverTimezone=UTC&quot;;
     String name = &quot;root&quot;;
     String pwd = &quot;156176pwd&quot;;
     String sql = &quot;INSERT INTO search(s_rank,s_title,s_view) VALUES(?,?,?)&quot;;
     String url = &quot;https://s.weibo.com/top/summary/summary?cate=realtimehot&quot;;

     try {
         // 连接数据库
         Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
         Connection connection = DriverManager.getConnection(myUrl, name, pwd);
         // 得到微博热搜数据
         Document document = Jsoup.connect(url).get();
         // 爬取指定微博热搜数据并储存
         Elements r = document.select(&quot;td[class=&#39;td-01 ranktop&#39;]&quot;);
         String[] rank = r.eachText().toArray(new String[0]);

         Elements t = document.select(&quot;td[class=&#39;td-02&#39;] a&quot;);
         String[] title = t.eachText().toArray(new String[0]);

         Elements v = document.select(&quot;span&quot;);
         String[] view = v.eachText().toArray(new String[0]);

         PreparedStatement statement = connection.prepareStatement(sql);
         statement.setString(1, &quot;top&quot;);
         statement.setString(2, title[0]);
         statement.setString(3, &quot;&quot;);
         statement.executeUpdate();
         // 插入mysql操作
         for (int i = 0; i &lt; rank.length; i++) {
             statement.setString(1, rank[i]);
             statement.setString(2, title[i + 1]);
             statement.setString(3, view[i]);
             statement.executeUpdate();
         } // 插入mysql操作
         connection.close();
     } catch (IOException e) {
         e.printStackTrace();
     } catch (ClassNotFoundException e) {
         e.printStackTrace();
     } catch (SQLException e) {
         e.printStackTrace();
     }
 }
}</code></pre>
</li>
<li><p>IDEA使用maven打包java<br>pom配置</p>
<pre><code>&lt;build&gt;
 &lt;plugins&gt;
     &lt;plugin&gt;
         &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
         &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
         &lt;version&gt;3.8.1&lt;/version&gt;
     &lt;/plugin&gt;
     &lt;plugin&gt;
         &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
         &lt;configuration&gt;
             &lt;archive&gt;
                 &lt;manifest&gt;
                     &lt;mainClass&gt;com.test.app&lt;/mainClass&gt;
                 &lt;/manifest&gt;
             &lt;/archive&gt;
             &lt;descriptorRefs&gt;
                 &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
             &lt;/descriptorRefs&gt;
         &lt;/configuration&gt;
         &lt;!--下面是为了使用 mvn package命令，如果不加则使用mvn assembly--&gt;
         &lt;executions&gt;
             &lt;execution&gt;
                 &lt;id&gt;make-assemble&lt;/id&gt;
                 &lt;phase&gt;package&lt;/phase&gt;
                 &lt;goals&gt;
                     &lt;goal&gt;single&lt;/goal&gt;
                 &lt;/goals&gt;
             &lt;/execution&gt;
         &lt;/executions&gt;
     &lt;/plugin&gt;
 &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
<h1 id="单独记录"><a href="#单独记录" class="headerlink" title="单独记录"></a>单独记录</h1><h2 id="Mysql-1"><a href="#Mysql-1" class="headerlink" title="Mysql"></a>Mysql</h2></li>
</ol>
</li>
<li><p>索引  </p>
<ul>
<li>定义<br>&emsp;&emsp;索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。(相当于目录，根据页码找内容)  </li>
<li>分类  </li>
</ul>
<ol>
<li>普通索引<br>&emsp;&emsp;普通索引是最基本的索引类型，唯一任务是加快对数据的访问速度，没有任何限制。创建普通索引时，通常使用的关键字是 INDEX 或 KEY。  </li>
<li>唯一性索引<br>&emsp;&emsp;唯一性索引是不允许索引列具有相同索引值的索引。如果能确定某个数据列只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字 UNIQUE 把它定义为一个唯一性索引。  </li>
<li>主键索引<br>&emsp;&emsp;主键索引是一种唯一性索引，即不允许值重复或者值为空，并且每个表只能有一个主键。主键可以在创建表的时候指定，也可以通过修改表的方式添加，必须指定关键字 PRIMARY KEY。</li>
<li>空间索引<br>&emsp;&emsp;空间索引主要用于地理空间数据类型 GEOMETRY。</li>
<li>全文索引<br>&emsp;&emsp;全文索引只能在 VARCHAR 或 TEXT 类型的列上创建，并且只能在 MyISAM 表中创建。</li>
</ol>
</li>
<li><p>执行计划<br>&emsp;&emsp;执行计划，就是一条SQL语句，在数据库中实际执行的时候，一步步的分别都做了什么。</p>
</li>
<li><p>事务<br>&emsp;&emsp;事务是逻辑上的一组操作，组成这组操作的各个单元，要不全都成功要不全都失败，这个特性就是事务。</p>
</li>
<li><p>幻读、脏读和不可重复读</p>
<ul>
<li>幻读<br>&emsp;&emsp;在一次事务里面，多次查询之后，结果集的个数不一致的情况叫做幻读。而多出来或者少的哪一行被叫做幻行。</li>
<li>脏读<br>&emsp;&emsp;脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。</li>
<li>不可重复读<br>&emsp;&emsp;在同一事务中，两次读取同一数据，得到内容不同。</li>
</ul>
</li>
<li><p>主键<br>&emsp;&emsp;主键是数据表的唯一索引，指的是一个列或多列的组合，其值能唯一地标识表中的每一行，通过它可强制表的实体完整性，主键主要是用与其他表的外键关联，以及本记录的修改与删除。</p>
</li>
<li><p>视图<br>&emsp;&emsp;视图是一种虚拟存在的表，是一个逻辑表，本身并不包含数据，作为一个select语句保存在数据字典中的。</p>
<h2 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h2></li>
<li><p>发展历史</p>
<ul>
<li>1995年5月23日，Java语言诞生</li>
<li>1996年1月，第一个JDK-JDK1.0诞生</li>
<li>1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术</li>
<li>1996年9月，约8.3万个网页应用了JAVA技术来制作</li>
<li>1997年2月18日，JDK1.1发布</li>
<li>1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录</li>
<li>1997年9月，JavaDeveloperConnection社区成员超过十万</li>
<li>1998年2月，JDK1.1被下载超过2,000,000次</li>
<li>1998年12月8日，JAVA2企业平台J2EE发布</li>
<li>1999年6月，SUN公司发布Java的三个版本：标准版（JavaSE,以前是J2SE）、企业版（JavaEE以前是J2EE）和微型版（JavaME，以前是J2ME）</li>
<li>2000年5月8日，JDK1.3发布</li>
<li>2000年5月29日，JDK1.4发布</li>
<li>2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机</li>
<li>2001年9月24日，J2EE1.3发布</li>
<li>2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升</li>
<li>2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0</li>
<li>2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字”2”：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME</li>
<li>2006年12月，SUN公司发布JRE6.0</li>
<li>2009年04月20日，甲骨文74亿美元收购Sun。取得java的版权。</li>
<li>2010年11月，由于甲骨文对于Java社区的不友善，因此Apache扬言将退出JCP。</li>
<li>2011年7月28日，甲骨文发布java7.0的正式版。</li>
</ul>
</li>
<li><p>命名规范</p>
<ul>
<li>包命名<br>全小写，由域名定义，一般采用自己在互联网上的域名(com.jianguo.service)。</li>
<li>类名<br>每个单词首字母大写(TestTime)。</li>
<li>方法名<br>首字母小写后面其他单词首字母大写(public static void openFile(){})。</li>
<li>常量名<br>全部大写常加”_”，并指出完整定义，多个单词组成用下划线分隔(public static final int NUMBER=0)。</li>
<li>参数名<br>与方法命名相同，尽量用一个单词(public void test(String str)中str)。</li>
<li>变量命名  </li>
</ul>
<ol>
<li>camel标记法：首字母小写，后面单词都以大写字母开头。  </li>
<li>pascal标记法：首字母大写，后面单词首字母大写。  </li>
<li>匈牙利标记法：在以pascal标记法的变量前附加小写序列说明变量类型(scope_typeVariableName)。</li>
</ol>
</li>
<li><p>Java bean</p>
<ul>
<li>JavaBean 是一种JAVA语言写成的可重用组件，为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器，JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性。  </li>
<li>JavaBean可分为两种：<br>&emsp;&emsp;一种是有用户界面（UI，User Interface）的JavaBean；还有一种是没有用户界面，主要负责处理事务（如数据运算，操纵数据库）的JavaBean。</li>
</ul>
</li>
<li><p>多态和继承</p>
<ul>
<li>多态<br>&emsp;&emsp;多态是同一个行为具有多个不同表现形式或形态的能力，是对象多种表现形式的体现(动物有很多种：狗，毛，鱼等)。</li>
<li>继承<br>&emsp;&emsp;继承是面向对象最显著的一个特性,是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力,是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</li>
</ul>
</li>
<li><p>Java mvc</p>
<ul>
<li>MVC 模式代表 Model-View-Controller(模型-视图-控制器)模式  </li>
</ul>
<ol>
<li>Model(模型)：模型代表一个存取数据的对象或 JAVA POJO,它也可以带有逻辑，在数据变化时更新控制器。  </li>
<li>View(视图)：视图代表模型包含的数据的可视化。</li>
</ol>
</li>
<li><p>异常处理</p>
<ul>
<li>异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。</li>
<li>异常发生的原因有很多，通常包含以下几大类：</li>
</ul>
<ol>
<li>用户输入了非法数据。  </li>
<li>要打开的文件不存在。  </li>
<li>网络通信时连接中断，或者JVM内存溢出。  </li>
</ol>
<ul>
<li>Exception类的层次<br>&emsp;&emsp;Exception 类是 Throwable 类的子类,有两个主要的子类：IOException 类和 RuntimeException 类。<br><img src="image%5Cexception.jpg" alt="Exception类的层次"><br><a href="https://www.w3cschool.cn/java/java-exceptions.html">异常处理</a></li>
</ul>
</li>
<li><p>Java 注解开发</p>
<ul>
<li>注解作用<br>&emsp;&emsp;用于告诉编译器javac或工具软件传达一种信息,相当于一个标记，加了注解就等于打上了某种标记，没加就等于没有某种标记，以后，javac编译器，开发工具和其他程序可以用反射来了解你的类及各种元素上有无何种标记，看你有什么标记就去干相应的事,标记可以加在包、类、方法、字段、方法的参数及局部变量上。</li>
<li>基本注解<br>&emsp;&emsp;Deprecated过时的,FunctionalInterface函数式接口：一种特殊类型的接口，这种接口中只定义了唯一的抽象方法的接口，Override 覆盖 ，SafeVarargs 可变参数安全性注解，SuppressWarnings过滤警告注解。</li>
<li>元注解  </li>
</ul>
<ol>
<li>@Retention标记注解的生命周期，三种取值分别为：RetentionPolicy.SOURCE RetentionPolicy.CLASS  RetentionPolicy.RUNNTIME 分别对应：源文件注解，class文件注解，内存中字节码，默认值是在class阶段@Override是在编译阶段覆盖的，因此它的Retention是source @SuppressWarnings也是source  Deprecated是runtime  。</li>
<li>@Target 标记给哪个元素添加注解取值分别为ElementType.Annotation_Type ElementType.Constructor ElementType.FIELD等等。</li>
</ol>
</li>
</ol>
